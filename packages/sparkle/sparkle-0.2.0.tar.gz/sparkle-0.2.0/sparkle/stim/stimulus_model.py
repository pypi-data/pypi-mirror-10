import copy
import logging
import os
import uuid

import numpy as np
import yaml

from sparkle.stim.auto_parameter_model import AutoParameterModel
from sparkle.stim.reorder import order_function
from sparkle.stim.types import get_stimuli_models
from sparkle.tools.audiotools import convolve_filter, impulse_response
from sparkle.tools.systools import get_src_directory

src_dir = get_src_directory()
# print 'src_dir', src_dir
with open(os.path.join(src_dir,'settings.conf'), 'r') as yf:
    config = yaml.load(yf)
DEFAULT_SAMPLERATE = config['default_genrate']

class StimulusModel():
    """
    Model to represent any stimulus the system will present. 
    Holds all relevant parameters
    """
    kernelCache = {} # persistent across all existing StimulusModels
    # these should always be the same application wide, so
    # use class variables
    voltage_limits = [None, None, 0.0] # speaker max, device max, device min
    def __init__(self):
        self._nreps = 1 # reps of each unique stimulus
        self._nloops = 1 # reps of entire expanded list of autoparams

        # 2D array of simulus components track number x component number
        self._segments = []
        # add an empty place to place components into new track
        self._autoParams = AutoParameterModel()
        
        # reference for what voltage == what intensity
        self.calv = None
        self.caldb = None
        self.impulseResponse = None

        self._attenuationVector = None
        self._calFrequencies = None
        self._calFrange = None

        self.stimid = uuid.uuid1()

        self.reorder = None
        self.reorderName = None
        self._userTag = '' # user enter tag
        self._stimType = None

        self._calibration_fs = None

    def setUserTag(self, tag):
        """Sets a string, significant to the user"""
        self._userTag = tag

    def userTag(self):
        """Returns a saved string, set by user"""
        return self._userTag

    def setStimType(self, t):
        """Sets the stimulus type this model represents, intention is to determine editor type"""
        self._stimType = t

    def stimType(self):
        """Stimulus type of this model (e.g. custom, tuning curve)"""
        return self._stimType

    def setReferenceVoltage(self, caldb, calv):
        """Sets the reference point to determine what outgoing voltage will produce what intensity, 
        used to calculate the proper output amplitude of components

        :param caldb: calibration intensity in dbSPL
        :type caldb: float
        :param calv: calibration voltage that was used to record the intensity provided
        :type calv: float
        """
        self.caldb = caldb
        self.calv = calv

    def setCalibration(self, dbBoostArray, frequencies, frange):
        """Sets the calibration to use with this stimulus, 
        creates a filter that will be applied to output signal generated by this model.
        Set arguments to `None` to clear calibration.

        :param dbBoostArray: frequency response of the system (in dB)
        :type dbBoostArray: numpy.ndarray
        :param frequencies: corresponding frequencies for the dbBoostArray
        :type frequencies: numpy.ndarray
        :param frange: The desired frequency range for which to apply the calibration, in Hz
        :type frange: (int, int)
        """
        if dbBoostArray is not None and frequencies is not None:
            logger = logging.getLogger('main')
            if dbBoostArray.shape != frequencies.shape:
                logger.error("ERROR: calibration array and frequency array must have same dimensions")
                return
            if frange is None:
                # maximum possible range
                frange = (frequencies[0], frequencies[-1])

            logger.debug('setting calibration with samplerate {}'.format(self.samplerate()))
            fs = self.samplerate()
            if fs in StimulusModel.kernelCache:
                logger.debug('---->using cached filter')
                # makes the assumption that the cache will be cleared if the frequency reponse
                # changes
                self.impulseResponse = StimulusModel.kernelCache[fs]
            else:
                logger.debug('---->calculating new filter for fs {}'.format(fs))
                self.impulseResponse = impulse_response(fs, dbBoostArray, frequencies, frange)
                # mutable type so will affect data structure persistently
                StimulusModel.kernelCache[fs] = self.impulseResponse

            # store this so we can quickly check if a calibration needs to be re-done    
            self._calibration_fs = fs
            
            # calculate for the default samplerate, if not already, since
            # we are very likely to need it, and it's better to have this done
            # up front, than cause lag in the UI later
            if DEFAULT_SAMPLERATE not in StimulusModel.kernelCache:
                StimulusModel.kernelCache[DEFAULT_SAMPLERATE] = impulse_response(DEFAULT_SAMPLERATE, dbBoostArray, frequencies, frange)

            # hang on to these for re-calculating impulse response on samplerate change
            self._attenuationVector = dbBoostArray
            self._calFrequencies = frequencies
            self._calFrange = frange

        else:
            self.impulseResponse = None

    def updateCalibration(self):
        """Updates the current calibration according to intenal values. For example, if the stimulus samplerate changes
        the calibration needs to be recalculated."""
        if self.samplerate() != self._calibration_fs:
            self.setCalibration(self._attenuationVector, self._calFrequencies, self._calFrange)

    @staticmethod
    def clearCache():
        """clears the calibration filters stored in the cache"""
        StimulusModel.kernelCache = {}

    def samplerate(self):
        """Returns the generation rate for this stimulus

        :returns: int -- the output samplerate (Hz)
        """
        rates = []
        for track in self._segments:
            for component in track:
                # special case, where component is a wav file:
                # it will set the master samplerate to match its own
                if component.__class__.__name__ == 'Vocalization':
                    if component.samplerate() is not None:
                        rates.append(component.samplerate())

        if len(set(rates)) > 1:
            # error check
            # raise Exception("Wav files with different sample rates in same stimulus")
            logger = logging.getLogger('main')
            logger.error("Wav files with different sample rates in same stimulus")
            return None
        elif len(set(rates)) == 1:
            return rates[0]
        else:
            return DEFAULT_SAMPLERATE

    def setAutoParams(self, params):
        """Overwrites the AutoParameterModel for this stimulus

        :param params: model to assign
        :type params: :class:`AutoParameterModel<sparkle.stim.auto_parameter_model.AutoParameterModel>`
        """
        self._autoParams = params

    def autoParams(self):
        """Returns the AutoParameterModel for this stimulus, which holds the auto-test information

        :returns: :class:`AutoParameterModel<sparkle.stim.auto_parameter_model.AutoParameterModel>`
        """
        return self._autoParams

    def rowCount(self):
        """Returns the number of tracks

        :returns: int -- number of rows
        """
        return len(self._segments)

    def columnCount(self, row=None):
        """Returns the number of components in a track, 
        or the max number of components in any row, if none given

        :param row: track to get count for
        :type row: int
        :returns: int -- number of components for *row*
        """
        if row is not None:
            wholerow = self._segments[row]
            return len(wholerow)
        else:
            column_lengths = [len(x) for x in self._segments]
            return max(column_lengths)

    def columnCountForRow(self, row):
        try:
            return len(self._segments[row])
        except IndexError:
            return 0

    def componentCount(self):
        """Returns the total number of components in stimulus

        :returns: number of components (not including expanded auto-params)
        """
        return sum([self.columnCountForRow(x) for x in range(self.rowCount())])

    def component(self, row, col):
        """Gets the components for the location

        :param row: track the component is in
        :type row: int
        :param col: the ith member of the track
        :type col: int
        :returns: :class:`AbstractStimulusComponent<sparkle.stim.abstract_component.AbstractStimulusComponent>`
        """
        try:
            comp = self._segments[row][col]
        except:
            # invalid index
            print 'Invalid index'
            return None
        return comp

    def insertComponent(self, comp, row=0, col=0):
        """Inserts component into model

        :param comp: Component to insert into the stimulus
        :type comp: :class:`AbstractStimulusComponent<sparkle.stim.abstract_component.AbstractStimulusComponent>`
        :param row: Track number to place comp in
        :type row: int
        :param col: location in track to insert component to
        :type col: int
        """
        if row > len(self._segments) -1:
            self.insertEmptyRow()
        self._segments[row].insert(col, comp)

        # in case of samplerate change, just always update
        self.updateCalibration()

    def overwriteComponent(self, comp, row, col):
        """Overwrites the component at the specficied location with a provided one.

        :param comp: New component to insert
        :type comp: :class:`AbstractStimulusComponent<sparkle.stim.abstract_component.AbstractStimulusComponent>`
        :param row: track location of existing component to overwrite
        :type row: int
        :param col: location in track of existing component to overwrite
        :type col: int
        """
        self._segments[row][col] = comp

        # in case of samplerate change, just always update
        self.updateCalibration()

    def insertEmptyRow(self):
        """Appends an empty track at the end"""
        self._segments.append([])

    def removeLastRow(self):
        """Removes the last track"""
        lastrow = self._segments.pop(len(self._segments)-1)
        if len(lastrow) > 0:
            raise Exception("Attempt to remove non-empty stimulus track")

    def removeRow(self, row):
        """Removes the track at row, empty or not"""
        self._segments.pop(row)

    def removeComponent(self, row,col):
        """Removes the component at the given location

        :param row: track location of existing component to remove
        :type row: int
        :param col: location in track of existing component to remove
        :type col: int
        """
        self._segments[row].pop(col)

        # If this row is now empty we should remove it?
        if self.columnCountForRow(-1) == 0:
            self.removeRow(len(self._segments)-1)

        # in case of samplerate change, just always update
        self.updateCalibration()


    def clearComponents(self):
        """Removes all components"""
        self._segments = []
        # also clear auto parameters
        self._autoParams.clearParameters()

    def indexByComponent(self, component):
        """Returns a location for the given component, or None if
        it is not in the model

        :param component: Component to get index for
        :type component: :class:`AbstractStimulusComponent<sparkle.stim.abstract_component.AbstractStimulusComponent>`
        :returns: (int, int) -- (row, column) of component
        """
        for row, rowcontents in enumerate(self._segments):
            if component in rowcontents:
                column = rowcontents.index(component)
                return (row, column)

    def traceCount(self):
        """The number of unique stimului for this stimulus object

        :returns: int -- The expanded trace count
        """
        nsegs = sum([len(track) for track in self._segments])
        if nsegs == 0:
            return 0
        ntraces = 1
        for irow in range(self._autoParams.nrows()):
            ntraces = ntraces*self._autoParams.numSteps(irow)
        return ntraces

    def loopCount(self):
        """The number of times to run through a set of autoparameters

        :returns: the number of times the auto-parameters and looped through
        """
        return self._nloops

    def setLoopCount(self, count):
        """Sets the number of times to loop through an entire set of autoparameters"""
        self._nloops = count

    def repCount(self):
        """Returns the number of repetitions each unique stimulus is presented"""
        return self._nreps

    def setRepCount(self, count):
        """Sets the number of repetitions each unique stimulus is presented"""
        if count > 0:
            self._nreps = count

    def contains(self, stimtype):
        """Returns whether the specified stimlus type is a component in this stimulus

        :param stimtype: :class:`AbstractStimulusComponent<sparkle.stim.abstract_component.AbstractStimulusComponent>` subclass class name to test for membership in the components of this stimulus
        :type stimtype: str
        :returns: bool -- if the stimtype is in the model
        """
        for track in self._segments:
            for component in track:
                if component.__class__.__name__ == stimtype:
                    return True
        return False

    def purgeAutoSelected(self):
        """Clears out orphaned auto parameters"""
        params = self._autoParams.allData()
        for p in params:
            comps_to_remove = []
            for comp in p['selection']:
                if self.indexByComponent(comp) is None:
                    comps_to_remove.append(comp)
            for orphaned in comps_to_remove:
                p['selection'].remove(orphaned)

    def cleanComponents(self):
        """Removes and references to UI objects from components. Allows them to be serializable"""
        for row in self._segments:
            for comp in row:
                comp.clean()

    def autoParamRanges(self):
        """Returns the expanded auto parameters, individually

        See :meth:`AutoParameterModel<sparkle.stim.auto_parameter_model.AutoParameterModel.ranges>`
        """
        return self._autoParams.ranges()
        
    def expandFunction(self, func, args=[]):
        """applies the given function to each of this stimulus's memerships when autoparamters are applied

        :param func: callable to execute for each version of the stimulus
        :type instancemethod:
        :param args: arguments to feed to func
        :type args: list
        :returns: list<results of *func*>, one for each trace
        """
        # initilize array to hold all varied parameters
        params = self._autoParams.allData()

        steps = self.autoParamRanges()
        ntraces = 1
        for p in steps:
            ntraces = ntraces*len(p)
        varylist = [[None for x in range(len(params))] for y in range(ntraces)]
        x = 1
        for iset, step_set in enumerate(steps):
            for itrace in range(ntraces):
                idx = (itrace / x) % len(step_set)
                varylist[itrace][iset] = step_set[idx]
            x = x*len(step_set)
        # now create the stimuli according to steps
        # go through list of modifing parameters, update this stimulus,
        # and then save current state to list
        stim_list = []
        for itrace in range(ntraces):
            for ip, param in enumerate(params):
                for component in param['selection']:
                    # print 'setting component {} parameter {} to {}'.format(component.name, param['parameter'], varylist[itrace][ip])
                    
                    # so I encountered a bug when the parameters were dragged the
                    # pickling/unpickling seems to either make a copy or somehow
                    # otherwise loose connection to the original components
                    # make sure to be setting the components that are in this model.
                    index = self.indexByComponent(component)
                    component = self.component(*index)

                    component.set(param['parameter'], varylist[itrace][ip])
            # copy of current stim state, or go ahead and turn it into a signal?
            # so then would I want to formulate some doc here as well?
            stim_list.append(func(*args))

        # now reset the components to start value
        for ip, param in enumerate(params):
            for component in param['selection']:
                component.set(param['parameter'], varylist[0][ip])

        return stim_list

    def setReorderFunc(self, func, name=None):
        """Sets the function that reorders the expanded signals of this stimulus

        :param func: a function which takes the template doc as an argument
        :type func: callable
        :param name: a name to assign the function (for documentation purposes)
        :type name: str
        """
        self.reorder = func
        self.reorderName = name

    def expandedStim(self):
        """
        Apply the autoparameters to this stimulus and return a list of
        the resulting stimuli, a complimentary list of doc dictionaries, and
        a complimentary list of undesired attenuations.

        :returns: list<numpy.ndarray>, list<dict>, list<float> -- the signals, their doc, undesired attenuations (dB)
        """
        logger = logging.getLogger('main')
        logger.debug("Generating Expanded Stimulus")

        # 3 loops now -- could be done in one...
        signals = self.expandFunction(self.signal)
        docs = self.expandFunction(self.componentDoc)
        overloads = []
        for s, d in zip(signals, docs):
            d['overloaded_attenuation'] = s[2]
            overloads.append(s[2])

        # remove the undesired attenuation argument
        signals = [sig[0:2] for sig in signals]

        if self.reorder:
            order = self.reorder(docs)
            signals = [signals[i] for i in order]
            docs = [docs[i] for i in order]

        return signals, docs, overloads

    def templateDoc(self):
        """JSON serializable template to will all necessary details to recreate this 
        stimulus in another session.
        
        :returns: dict
        """
        doc = dict(self.componentDoc(False).items() + self.testDoc().items())

        # go through auto-parameter selected components and use location index
        autoparams = copy.deepcopy(self._autoParams.allData())
        for p in autoparams:
            selection = p['selection']
            serializable_selection = []
            for component in selection:
                idx = self.indexByComponent(component)
                serializable_selection.append(idx)
            p['selection'] = serializable_selection

        doc['autoparameters'] = autoparams
        doc['reorder'] = self.reorderName
        return doc

    @staticmethod
    def loadFromTemplate(template, stim=None):
        """Loads the stimlus to the state provided by a template

        :param template: dict that includes all info nesessary to recreate stim
        :type template: dict
        :param stim: Stimulus to apply to, creates a new model if None
        :type stim: StimulusModel
        """
        if stim is None:
            stim = StimulusModel()
        stim.setRepCount(template['reps'])
        stim.setUserTag(template.get('user_tag', ''))
        # don't set calibration details - this should be the same application wide
        component_classes = get_stimuli_models()
        for comp_doc in template['components']:
            comp = get_component(comp_doc['stim_type'], component_classes)
            comp.loadState(comp_doc) # ignore extra dict entries
            stim.insertComponent(comp, *comp_doc['index'])

        # revert from location based selection to component list
        autoparams = template['autoparameters']
        for p in autoparams:
            selection = p['selection']
            component_selection = []
            for index in selection:
                component = stim.component(*index)
                component_selection.append(component)
            p['selection'] = component_selection

        stim.autoParams().setParameterList(autoparams)
        stim.setReorderFunc(order_function(template['reorder']), template['reorder'])
        stim.setStimType(template['testtype'])
        return stim

    @staticmethod
    def signalFromDoc(doc, calv, caldb):
        # use the output from ComponentDoc to create a single (no auto-params)
        # stimulus and return it's signal
        stim = StimulusModel()    
        component_classes = get_stimuli_models()
        if len(doc['components']) == 1 and doc['components'][0]['stim_type'] == 'silence':
            return np.array([0,0])
        for comp_doc in doc['components']:
            comp = get_component(comp_doc['stim_type'], component_classes)
            comp.loadState(comp_doc) # ignore extra dict entries
            stim.insertComponent(comp, *comp_doc['index'])
        
        stim.setReferenceVoltage(calv, caldb)
        signal, atten, sad_atten = stim.signal(force_fs=doc['samplerate_da'])
        return signal

    def duration(self):
        """The duration of this stimulus

        :returns: float -- duration in seconds
        """
        durs = []
        for track in self._segments:
            durs.append(sum([comp.duration() for comp in track]))
            
        return max(durs)

    def signal(self, force_fs=False):
        """The current stimulus in signal representation, this is the sum
        of its components

        :param force_fs: Allow to use a different samplerate than the default, should be used to recreate historical signals only
        :type force_fs: int
        :returns: numpy.ndarray -- voltage signal for this stimulus
        """
        assert None not in self.voltage_limits, 'Max voltage level not set'
        if force_fs:
            samplerate = force_fs
        else:
            samplerate = self.samplerate()
        track_signals = []
        max_db = max([comp.intensity() for t in self._segments for comp in t])
        # atten = self.caldb - max_db
        atten = 0
        # if max_db > self.caldb:
        #     raise Exception("Stimulus intensity over maxium")
        # print 'caldb:', self.caldb, 'max db:', max_db, 'atten:', atten, 'calv', self.calv
        for track in self._segments:
            track_list = []
            for component in track:
                track_list.append(component.signal(fs=samplerate, 
                                                   atten=0, 
                                                   caldb=self.caldb, 
                                                   calv=self.calv))
            if len(track_list) > 0:   
                track_signals.append(np.hstack(track_list))

        # track_signals = sorted(track_signals, key=len, reverse=True)
        full_len = len(max(track_signals, key=len))
        total_signal = np.zeros((full_len,))
        for track in track_signals:
            total_signal[0:len(track)] += track

        # if there is only square waves in stimulus, do not apply calibration --
        # it is assumed to not be a signal for the speaker
        component_names = list(set([comp.name for track in self._segments for comp in track]))
        if 'silence' in component_names:
            component_names.remove('silence')
        if len(component_names) > 1 or (len(component_names) == 1 and component_names[0] != "Square Wave"):
            total_signal = convolve_filter(total_signal, self.impulseResponse)
            maxv = self.voltage_limits[0]
            to_speaker = True
        else:
            maxv = self.voltage_limits[1]
            to_speaker = False

        # last sample should always go to 0, so output isn't stuck on some
        # other value when stim ends
        total_signal[-1] = 0

        undesired_attenuation = 0

        # sig_max = max(abs(total_signal))
        # if sig_max > self.calv:
        #     over_db = 20 * np.log10(sig_max/self.calv)
        #     allowance = float(min(over_db, atten))
        #     scalev = (10 ** (allowance/20)*self.calv)
        #     total_signal = total_signal/scalev
        #     print 'sigmax {}, over_db {}, allowance {}, scalev {}'.format(sig_max, over_db, allowance, scalev)
        #     atten -= allowance
        minv = self.voltage_limits[2]
        sig_max = np.max(abs(total_signal))
        if sig_max > maxv:
            # scale stim down to outputable max
            total_signal = (total_signal/sig_max)*maxv
            attenuated = 20 * np.log10(sig_max/maxv)

            if attenuated <= atten:
                atten = atten - attenuated
            else:
                undesired_attenuation = attenuated - atten
                atten = 0
                logger = logging.getLogger('main')
                logger.warning("STIMULUS AMPLTIUDE {:.2f}V EXCEEDS MAXIMUM({}V), RESCALING. \
                    UNDESIRED ATTENUATION {:.2f}dB".format(sig_max, maxv, undesired_attenuation))
        elif sig_max < minv and sig_max !=0 and to_speaker:
            before_rms = np.sqrt(np.mean(pow(total_signal,2)))
            total_signal = (total_signal/sig_max)*minv
            after_rms = np.sqrt(np.mean(pow(total_signal,2)))
            attenuated = -20 * np.log10(before_rms/after_rms)
            # print 'signal below min, adding {} attenuation'.format(attenuated)
            atten += attenuated

        return total_signal, atten, undesired_attenuation

    def componentDoc(self, starttime=True):
        """The documentation for the components, as a dict

        :returns dict -- values are the generation samplerate, and a list of 
                         the individual component docs
        """
        samplerate = self.samplerate()
        doc_list = []
        for row, track in enumerate(self._segments):
            start_time = 0
            for col, component in enumerate(track):
                info = component.stateDict()
                info['stim_type'] = component.name
                if starttime:
                    info['start_s'] = start_time
                info['index'] = (row, col)
                start_time += info['duration']
                doc_list.append(info)
                
        return {'samplerate_da':samplerate, 'components' : doc_list}

    def testDoc(self):
        """The common doc that applies to all traces (auto-params) contained 
        within

        :returns: dict
        """
        return {'reps': self._nreps, 'user_tag': self._userTag,
                'calv': self.calv, 'caldb':self.caldb, 'testtype': self._stimType}

    def updateComponentStartVals(self):
        """Go through selected components for each auto parameter and set the 
        start value
        """
        self._autoParams.updateComponentStartVals()
        # for param in self._autoParams.allData():
        #     for component in param['selection']:
        #         component.set(param['parameter'], param['start'])

    def containsPval(self, paramName, value):
        """Returns true if *value* for parameter type *paramName* is in the 
        auto parameters

        :param paramName: the name of the auto-parameter to match, e.g. 'frequency'
        :type paramName: str
        :param value: the value of the parameter to search for
        :returns: bool
        """
        # this may break if there are two parameters in the model with 
        # the same parameter type!!!
        params = self._autoParams.allData()
        steps = self.autoParamRanges()
        pnames = [p['parameter'] for p in params]
        if paramName in pnames:
            pidx = pnames.index(paramName)
            return value in steps[pidx]
        else:
            return False

    def warning(self):
        """Checks Stimulus for any warning conditions

        :returns: str -- warning message, if any, 0 otherwise
        """
        signals, docs, overs = self.expandedStim()
        if np.any(np.array(overs) > 0):
            msg = 'Stimuli in this test are over the maximum allowable \
                voltage output. They will be rescaled with a maximum \
                undesired attenuation of {:.2f}dB.'.format(np.amax(overs))
            return msg
        return 0

    def verifyExpanded(self, samplerate):
        """Checks the expanded parameters for invalidating conditions

        :param samplerate: generation samplerate (Hz), passed on to component verification
        :type samplerate: int
        :returns: str -- error message, if any, 0 otherwise"""
        results = self.expandFunction(self.verifyComponents, args=(samplerate,))
        msg = [x for x in results if x]
        if len(msg) > 0:
            return msg[0]
        else:
            return 0

    def verifyComponents(self, samplerate):
        """Checks the current components for invalidating conditions

        :param samplerate: generation samplerate (Hz), passed on to component verification
        :type samplerate: int
        :returns: str -- error message, if any, 0 otherwise
        """
        # flatten list of components
        components = [comp for track in self._segments for comp in track]
        for comp in components:
            msg = comp.verify(samplerate=samplerate)
            if msg:
                return msg
        return 0

    def verify(self, windowSize=None):
        """Checks the stimulus, including expanded parameters for invalidating conditions

        :param windowSize: acquistion (recording) window size (seconds)
        :type windowSize: float
        :returns: str -- error message, if any, 0 otherwise"""
        if self.samplerate() is None:
            return "Multiple recording files with conflicting samplerates"
        msg = self._autoParams.verify()
        if msg:
            return msg
        if self.traceCount() == 0:
            return "Test is empty"
        if windowSize is not None:
            durations = self.expandFunction(self.duration)
            # print 'windowSize', windowSize, 'self', durations[0],  durations[-1]
            # ranges are linear, so we only need to test first and last
            if durations[0] > windowSize or durations[-1] > windowSize:
                return "Stimulus duration exceeds window duration"
        msg = self.verifyExpanded(self.samplerate())
        if msg:
            return msg
        if self.caldb is None or self.calv is None:
            return "Test reference voltage not set"
        return 0

    @staticmethod
    def setMaxVoltage(maxv, device_maxv):
        StimulusModel.voltage_limits[0] = maxv
        StimulusModel.voltage_limits[1] = device_maxv

    @staticmethod
    def setMinVoltage(minv):
        if minv is None:
            minv = 0.0
        StimulusModel.voltage_limits[2] = minv

    def __eq__(self, other):
        if self.stimid == other.stimid:
            return True
        else:
            return False


def get_component(comp_name, class_list):
    """Returns an implementation of the class refered to by *comp_name* 
    if it is in *class_list*
    """
    for comp_class in class_list:
        if comp_class.name == comp_name:
            return comp_class()
    else:
        return None
