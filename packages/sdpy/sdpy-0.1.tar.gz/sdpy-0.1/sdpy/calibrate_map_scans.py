import astropy.io.fits as pyfits
import numpy as np
import warnings
from astropy import log

from .timer import print_timing


def load_data_file(filename, extension=1, dataarr=None, filepyfits=None,
                   datapfits=None):
    """
    Load the series of spectra from a raw SDFITS file
    """

    if filepyfits is not None:
        datapyfits = filepyfits[extension].data
    else:
        try:
            print "Treating file as an open FITS HDU... ",
            datapyfits = filename[extension].data
        except AttributeError:
            print "File is not an HDU.  Reading file from disk using pyfits...",
            if isinstance(filename,str):
                filepyfits = pyfits.open(filename,memmap=True)
                datapyfits = filepyfits[extension].data
            else:
                print "Assuming file is a FITS BinaryTableHDU"
                datapyfits = filename
    if dataarr is None:
        dataarr = datapyfits['DATA']
    print "Data successfully read"
    namelist = datapyfits.names
    data = datapyfits

    # Don't do this any more; reads whole thing into memory
    #if dataarr.sum() == 0 or dataarr[-1,:].sum() == 0:
    #    print "Reading file using pfits because pyfits didn't read any values!"
    #    import pfits
    #    if datapfits is not None:
    #        data = datapfits
    #    else:
    #        data = pfits.FITS(filename).get_hdus()[1].get_data()

    #    dataarr = np.reshape(data['DATA'],data['DATA'].shape[::-1])

    #    namelist = data.keys()

    return data, dataarr, namelist, filepyfits

@print_timing
def calibrate_cube_data(filename, outfilename, scanrange=[],
                        sourcename=None, feednum=1, sampler=0,
                        return_data=False, datapfits=None, dataarr=None,
                        clobber=True, tau=0.0, obsmode=None, refscans=None,
                        tauz=0.0,
                        off_template=None, filepyfits=None,
                        refscan1=None, refscan2=None,
                        exclude_spectral_ends=10., extension=1,
                        min_scale_reference=False,
                        verbose=1,
                        tsysmethod='perscan',
                        tatm=273.0,
                        trec=None,
                        airmass_method='maddalena',
                        scale_airmass=True,
                        ):
    """
    The calibration process in pseudocode:

    # Create a "reference spectrum" on blank sky
    refspec = mean(refspec_calon,refspec_caloff)
    # Determine TSYS, the total atmospheric + astrophysical + receiver noise
    # temperature
    tsys = tcal * mean_continuum(cal_off) / (mean_continuum(cal_on - cal_off)) + tcal/2.0

    # for "TOTAL POWER" mode
    # Remove the atmospheric and receiver contribution
    tsource = tsys - (np.exp(tau*airmass)-1)*tatm - trec
    tsource_star = tsource * np.exp(tau*airmass)

    # for SIG-REF mode (signal + reference; on/off nod)
    calSpec = (spec-specRef)/specRef * tsys


    How does GBTIDL do it?
    in dcmeantsys.pro_, the +/-10% edge channels are excluded, and
        mean_tsys = mean(cal_off) / (mean(cal_on-cal_off)) * tcal + tcal/2.0
    in dototalpower.pro_, the data is set to tp_data = (cal_on + cal_off) / 2.0
    in dofullsigref.pro_, tsys is corrected with airmass=1/sin(elev)
    in dosigref.pro_, sigrefdata = (tpdata - refdata)/refdata * tsys


    .. dofullsigref.pro_: http://www.gb.nrao.edu/GBT/DA/gbtidl/release/user/toolbox/dofullsigref.html

    Parameters
    ----------
    filename : str
        input file name
    outfilename : str
        output file name
    scanrange : 2-tuple
        *DATA SELECTION PARAMETER* Range of scans to include when creating off
        positions
    sourcename : str or None
        *DATA SELECTION PARAMETER* Name of source to include
    feednum : int
        *DATA SELECTION PARAMETER* Feed number to use (1 for single-feed
        systems)
    sampler : str
        *DATA SELECTION PARAMETER* Sampler to create the off for (e.g., 'A9')
    obsmode : str
        *DATA SELECTION PARAMETER* Observation Mode to include (e.g.,
        DecLatMap)
    dataarr : None or np.ndarray
        OPTIONAL input of data array.  If it has already been read, this param
        saves time
    tau : float
        Zenith optical depth
        [Deprecated, use tauz]
    tauz : float
        Zenith optical depth
    off_template : np.ndarray
        A spectrum representing the 'off' position generated by make_off
        (normalized!)
    refscans: list
        Reference scans at beginning & end of observation (probably).  These
        are used as a spectroscopic off template unless off_template is
        specified, but they are always used to determine the continuum
        "zero-point"
    exclude_spectral_ends: float
        PERCENT (range [0,100]) of the spectrum to exclude at either end when
        computing TSYS etc.
    min_scale_reference: False or float
        EXPERIMENTAL: rescale the "reference" to be the scan of lowest TSYS,
        then use the value of min_scale_reference as a percentile to determine
        the integration to use from that scan.  Try 10.
        WARNING: Can cause major problems if obserations occur at highly
        variable airmass!
    tsysmethod: 'perscan' or 'perint'
        Compute tsys for each scan or for each integration?
    verbose: int
        Level of verbosity.  0 is none, 1 is some, 2 is very, 3 is very lots
    tatm: float
        The atmospheric temperature.  Will be subtracted from TSYS using the
        provided optical depth and assuming a plane-parallel atmosphere, 
        which is good down to 8 degrees
        (http://www.gb.nrao.edu/~rmaddale/GBT/HighPrecisionCalibrationFromSingleDishTelescopes.pdf)
    trec: float
        Not presently used
    airmass_method: float
        Method of airmass determination, either csc(elev) or Ron Maddalena's
        version
    scale_airmass: bool
        If the min_scale_reference method is used, try to re-scale the off
        position mean by the airmass
    """

    if tau != 0:
        if tauz != 0:
            raise ValueError("Only use tauz, not both tau and tauz")
        else:
            tauz = tau
            warnings.warn("Use tauz instead of tau",
                          DeprecationWarning)

    if refscan1 is not None or refscan2 is not None:
        warnings.warn("Use refscans (a list of scans) rather than ref1,ref2",
                      DeprecationWarning)
        if (type(refscans) == list and not
            (len(refscans) ==2 and
             refscans[0] == refscan1 and refscans[1] == refscan2)):
            raise ValueError('refscans does not match refscan1,2')
        elif refscans is None:
            refscans = refscan1,refscan2

    data, dataarr, namelist, filepyfits = load_data_file(filename,
                                                         extension=extension,
                                                         dataarr=dataarr,
                                                         datapfits=datapfits,
                                                         filepyfits=filepyfits)

    newdatadict = dict([(n,[]) for n in namelist])
    formatdict = dict([(t.name,t.format) for t in filepyfits[extension].columns])

    samplers = np.unique(data['SAMPLER'])
    if isinstance(sampler,int):
        sampler = samplers[sampler]

    OK = data['SAMPLER'] == sampler
    OK *= data['FEED'] == feednum
    OK *= np.isfinite(data['DATA'].sum(axis=1))
    OKsource = OK.copy()
    if sourcename is not None:
        OKsource &= (data['OBJECT'] == sourcename)
    if scanrange is not []:
        OKsource &= (scanrange[0] < data['SCAN'])*(data['SCAN'] < scanrange[1])
    if obsmode is not None:
        OKsource &= ((obsmode == data.OBSMODE) |
                     ((obsmode+":NONE:TPWCAL") == data.OBSMODE))
    if sourcename is None and scanrange is None:
        raise IndexError("Must specify a source name and/or a scan range")

    if verbose:
        log.info("Beginning scan selection and calibration for "
                 "sampler %s and feed %s" % (sampler,feednum))

    CalOff = (data['CAL']=='F')
    CalOn  = (data['CAL']=='T')

    speclen = dataarr.shape[1]

    # Fraction of ends to exclude.  exslice = "Exclusion Slice"
    exfrac = exclude_spectral_ends/100.
    exslice = slice(speclen*exfrac,-speclen*exfrac)

    # reference scans define the "background continuum"
    if type(refscans) == list:
        # split into two steps for readability
        temp_ref = get_reference(data, refscans, CalOn=CalOn, CalOff=CalOff,
                                 exslice=exslice, OK=OK)
        LSTrefs, refarray, ref_cntstoK, tsysref = temp_ref
    else:
        raise TypeError("Must specify reference scans as a list of scan numbers.")

    if verbose:
        log.info("Beginning calibration of %i scans." % ((OKsource*CalOn).sum()))

    if ((OKsource*CalOn).sum()) == 0:
        import pdb; pdb.set_trace()
        raise ValueError("There are no locations where the source was observed"
                         " with the calibration diode on.  That can't be right.")

    compute_tsys(data, tsysmethod=tsysmethod, OKsource=OKsource, CalOn=CalOn,
                 CalOff=CalOff, exslice=exslice, verbose=verbose)

    # experimental: try to rescale the "reference" scan to be the minimum
    if min_scale_reference:
        ref_scale,ref_airmass = get_min_scale_reference(data,
                                                        min_scale_reference,
                                                        OKsource=OKsource,
                                                        CalOn=CalOn,
                                                        CalOff=CalOff,
                                                        exslice=exslice,
                                                        airmass_method=airmass_method)
        if verbose:
            log.info("EXPERIMENTAL: min_scale_reference = {0}".format(ref_scale))
    
    for specindOn,specindOff in zip(np.where(OKsource*CalOn)[0],
                                    np.where(OKsource*CalOff)[0]):

        for K in namelist:
            if K != 'DATA':
                newdatadict[K].append(data[K][specindOn])
            else:
                # should this be speclen or 4096?  Changing to speclen...
                newdatadict['DATA'].append(np.zeros(speclen))

        # http://www.gb.nrao.edu/~rmaddale/Weather/
        elev = data['ELEVATIO'][specindOn]
        airmass = elev_to_airmass(elev,
                                  method=airmass_method)

        specOn = dataarr[specindOn,:]
        specOff = dataarr[specindOff,:]
        spec = (specOn + specOff)/2.0
        LSTspec = data['LST'][specindOn]

        # this "if" test is no longer necessary
        if refscans is not None:
            # find the reference scan closest to the current scan
            # (LSTspec is a number, LSTrefs is an array, probably length 2)
            refscannumber = np.argmin(np.abs(LSTspec-LSTrefs))
            # if the closest reference scan is the last or it is after the spectrum...
            # the earlier reference scan has index self-1
            if refscannumber == len(refscans) - 1 or LSTrefs[refscannumber] > LSTspec:
                r1 = refscannumber - 1
                r2 = refscannumber
            elif LSTrefs[refscannumber] < LSTspec:
                r1 = refscannumber
                r2 = refscannumber + 1
            LSTref1 = LSTrefs[r1]
            LSTref2 = LSTrefs[r2]
            specref1 = refarray[r1,:]
            specref2 = refarray[r2,:]
            LSTspread = LSTref2-LSTref1

        # LINEAR interpolation between the reference scans
        specRef = (specref2-specref1)/LSTspread*(LSTspec-LSTref1) + specref1
        # EXPERIMENTAL
        if min_scale_reference:
            if verbose > 2:
                log.info("Rescaling specRef from {0} to {1}"
                         .format(specRef[exslice].mean(),ref_scale))
            specRef = specRef/specRef[exslice].mean() * ref_scale
            if scale_airmass:
                specRef += tatm/ref_cntstoK*(np.exp(-tauz*ref_airmass)-np.exp(-tauz*airmass))


        # use a templated OFF spectrum
        # (e.g., one that has had spectral lines interpolated over)
        if off_template is not None:
            if off_template.shape != specRef.shape:
                raise ValueError("Off template shape does not match spectral shape")
            # exclude spectral ends when ratio-ing
            specRef = off_template * specRef[exslice].mean() / off_template[exslice].mean()

        tsys = data['TSYS'][specindOn]
        
        # I don't think this is right... the correct way is to make sure
        # specRef moves with Spec
        #tsys_eff = tsys * np.exp(tau*airmass) - (np.exp(tau*airmass)-1)*tatm
        tsys_eff = tsys * np.exp(tauz*airmass)

        calSpec = (spec-specRef)/specRef * tsys_eff
        if calSpec.sum() == 0:
            raise ValueError("All values in calibrated spectrum are zero")

        newdatadict['TSYS'][-1] = tsys
        newdatadict['DATA'][-1] = calSpec

    # how do I get the "Format" for the column definitions?

    # Make Table
    cols = [pyfits.Column(name=key,format=formatdict[key],array=value)
            for key,value in newdatadict.iteritems()]
    colsP = pyfits.ColDefs(cols)
    #tablehdu = copy.copy(filepyfits[extension])
    #tablehdu.data = colsP
    # this lies and claims corrupted 
    tablehdu = pyfits.new_table(colsP, header=filepyfits[extension].header)
    phdu = pyfits.PrimaryHDU(header=filepyfits[0].header)
    hdulist = pyfits.HDUList([phdu,tablehdu])
    hdulist.writeto(outfilename,clobber=clobber)
    
    #tablehdu.writeto(outfilename,clobber=clobber)

    if return_data:
        return filepyfits,data,colsP


def compute_tsys(data, tsysmethod='perscan', OKsource=None, CalOn=None,
                 CalOff=None, verbose=False, exslice=slice(None)):
    """
    Calculate the TSYS vector for a set of scans

    from GBTIDL's dcmeantsys.py
    ;  mean_tsys = tcal * mean(nocal) / (mean(withcal-nocal)) + tcal/2.0
    
    """
    if CalOn is None:
        CalOn  = (data['CAL']=='T')
    if CalOff is None:
        CalOff = (data['CAL']=='F')

    dataarr = data['DATA']

    if OKsource is None:
        OKsource = np.ones(dataarr.shape[0], dtype='bool')

    if tsysmethod == 'perscan':
        # compute TSYS on a scan-by-scan basis to avoid problems with saturated
        # TSYS.
        scannumbers = np.unique(data['SCAN'][OKsource])
        for scanid in scannumbers:
            whscan = data['SCAN'] == scanid

            on_data = dataarr[whscan & CalOn,exslice]
            off_data = dataarr[whscan & CalOff,exslice]
            tcal = np.median(data['TCAL'][whscan])

            offmean = np.median(off_data,axis=0).mean()
            onmean  = np.median(on_data,axis=0).mean()
            diffmean = onmean-offmean

            tsys = (offmean / diffmean * tcal + tcal/2.0)
            if verbose > 1:
                print "Scan %4i:  TSYS=%12.3f" % (scanid,tsys)
            data['TSYS'][whscan] = tsys
    elif tsysmethod == 'perint':
        on_data = dataarr[CalOn & OKsource,exslice]
        off_data = dataarr[CalOff & OKsource,exslice]
        tcal = data['TCAL'][CalOn & OKsource]

        offmean = np.mean(off_data,axis=1)
        onmean  = np.mean(on_data,axis=1)
        diffmean = onmean-offmean

        # K / count = tcal / diffmean
        tsys = (offmean / diffmean * tcal + tcal/2.0)
        data['TSYS'][CalOn & OKsource] = tsys
        data['TSYS'][CalOff & OKsource] = tsys
        
    return data['TSYS']

def elev_to_airmass(elev, method='maddalena'):
    """
    Calculate the airmass with np.csc(elev) or Ron Maddalena's improved method
    for low elevations

    http://www.gb.nrao.edu/~rmaddale/GBT/HighPrecisionCalibrationFromSingleDishTelescopes.pdf
    """
    if method != 'maddalena':
        return 1/np.sin(elev/180*np.pi)
    else:
        # http://www.gb.nrao.edu/~rmaddale/GBT/HighPrecisionCalibrationFromSingleDishTelescopes.pdf
        return -0.0234+1.014/np.sin((elev+5.18/(elev+3.35))*np.pi/180.)

def get_min_scale_reference(data, min_scale_reference, OKsource=None,
                            CalOn=None, CalOff=None, verbose=False,
                            exslice=slice(None), airmass_method='maddalena'):

    if CalOn is None:
        CalOn  = (data['CAL']=='T')
    if CalOff is None:
        CalOff = (data['CAL']=='F')

    min_tsys = np.argmin(data['TSYS'][OKsource])
    whmin = data['SCAN'][OKsource][min_tsys]
    whscan = data['SCAN'] == whmin
    dataarr = data['DATA']
    r1 = np.percentile(dataarr[whscan*OKsource*CalOn,exslice],
                       min_scale_reference, axis=0)
    r2 = np.percentile(dataarr[whscan*OKsource*CalOff,exslice],
                       min_scale_reference, axis=0)
    ref_scale = np.median((r1+r2)/2.0)
    ref_airmass = elev_to_airmass(data['ELEVATIO'][OKsource][min_tsys],
                                  method=airmass_method)

    return ref_scale,ref_airmass


def get_reference(data, refscans, CalOn=None, CalOff=None,
                  exslice=slice(None), OK=None):
    """
    Extract the reference scans from the data.

    Parameters
    ----------
    data: FITS table
        Table of the data and associated metadata
    refscans: list
        List of scan numbers
    CalOn/CalOff: boolean arrays
        Optional; if not specified they will be recomputed.  Boolean arrays
        identified the on/off regions of the data
    exslice: slice
        Slice along the spectral axis for computing means
    OK: boolean array
        Mandatory.  All valid spectra for the specified feed and sampler
    """
    if CalOn is None:
        CalOn  = (data['CAL']=='T')
    if CalOff is None:
        CalOff = (data['CAL']=='F')

    dataarr = data['DATA']
    speclen = dataarr.shape[1]

    refarray = np.zeros([len(refscans),speclen])
    LSTrefs  = np.zeros([len(refscans)])
    for II,refscan in enumerate(refscans):
        OKref = OK & (refscan == data['SCAN'])
        # use "where" in case that reduces amount of stuff read in...
        CalOnRef = np.nonzero(OKref & CalOn)[0]
        CalOffRef = np.nonzero(OKref & CalOff)[0]

        specrefon  = np.median(dataarr[CalOnRef,:],axis=0)
        specrefoff = np.median(dataarr[CalOffRef,:],axis=0)
        tcalref    = np.median(data['TCAL'][OKref])
        ref_cntstoK = tcalref/np.mean((specrefon-specrefoff)[exslice])
        #tsysref    = ( np.mean(specrefoff[exslice]) /
        #        (np.mean((specrefon-specrefoff)[exslice])) *
        #        tcalref + tcalref/2.0 )
        tsysref = np.mean(specrefoff[exslice]) * ref_cntstoK + tcalref/2.0
        refarray[II] = (specrefon + specrefoff)/2.0
        LSTrefs[II]  = np.mean(data['LST'][OKref])
        if specrefon.sum() == 0 or specrefoff.sum() == 0:
            raise ValueError("All values in reference scan %i are zero" % refscan)
        elif np.isnan(specrefon).sum() > 0 or np.isnan(specrefoff).sum() > 0:
            raise ValueError("Reference scan %i contains a NAN" % refscan)

    return LSTrefs, refarray, ref_cntstoK, tsysref
