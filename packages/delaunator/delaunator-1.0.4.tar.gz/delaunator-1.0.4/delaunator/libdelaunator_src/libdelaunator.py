# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libdelaunator', [dirname(__file__)])
        except ImportError:
            import _libdelaunator
            return _libdelaunator
        if fp is not None:
            try:
                _mod = imp.load_module('_libdelaunator', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libdelaunator = swig_import_helper()
    del swig_import_helper
else:
    import _libdelaunator
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libdelaunator.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _libdelaunator.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _libdelaunator.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _libdelaunator.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _libdelaunator.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _libdelaunator.SwigPyIterator_equal(self, x)

    def copy(self):
        return _libdelaunator.SwigPyIterator_copy(self)

    def next(self):
        return _libdelaunator.SwigPyIterator_next(self)

    def __next__(self):
        return _libdelaunator.SwigPyIterator___next__(self)

    def previous(self):
        return _libdelaunator.SwigPyIterator_previous(self)

    def advance(self, n):
        return _libdelaunator.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _libdelaunator.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _libdelaunator.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _libdelaunator.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _libdelaunator.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _libdelaunator.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _libdelaunator.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _libdelaunator.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_libdelaunator.FILE_LOGS_swigconstant(_libdelaunator)
FILE_LOGS = _libdelaunator.FILE_LOGS

def swap(arg1, arg2, arg3):
    return _libdelaunator.swap(arg1, arg2, arg3)
swap = _libdelaunator.swap

def strAfter(arg1, arg2):
    return _libdelaunator.strAfter(arg1, arg2)
strAfter = _libdelaunator.strAfter

def randstr(size, caracs):
    return _libdelaunator.randstr(size, caracs)
randstr = _libdelaunator.randstr

def logs(arg1):
    return _libdelaunator.logs(arg1)
logs = _libdelaunator.logs

def round_float(arg1, arg2):
    return _libdelaunator.round_float(arg1, arg2)
round_float = _libdelaunator.round_float

_libdelaunator.EPSILON_swigconstant(_libdelaunator)
EPSILON = _libdelaunator.EPSILON
class Coordinates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Coordinates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Coordinates, name)
    __repr__ = _swig_repr

    def __init__(self, x=0., y=0.):
        this = _libdelaunator.new_Coordinates(x, y)
        try:
            self.this.append(this)
        except:
            self.this = this

    def squareDistanceTo(self, othr):
        return _libdelaunator.Coordinates_squareDistanceTo(self, othr)

    def distanceTo(self, othr):
        return _libdelaunator.Coordinates_distanceTo(self, othr)

    def x(self):
        return _libdelaunator.Coordinates_x(self)

    def y(self):
        return _libdelaunator.Coordinates_y(self)

    def setX(self, x):
        return _libdelaunator.Coordinates_setX(self, x)

    def setY(self, y):
        return _libdelaunator.Coordinates_setY(self, y)

    def setCoord(self, x, y):
        return _libdelaunator.Coordinates_setCoord(self, x, y)

    def __eq__(self, othr):
        return _libdelaunator.Coordinates___eq__(self, othr)

    def __ne__(self, othr):
        return _libdelaunator.Coordinates___ne__(self, othr)

    def __add__(self, c):
        return _libdelaunator.Coordinates___add__(self, c)

    def __sub__(self, c):
        return _libdelaunator.Coordinates___sub__(self, c)

    def __div__(self, value):
        return _libdelaunator.Coordinates___div__(self, value)

    def __iadd__(self, c):
        return _libdelaunator.Coordinates___iadd__(self, c)
    __swig_getmethods__["x"] = x
    __swig_setmethods__["x"] = setX
    __swig_getmethods__["y"] = y
    __swig_setmethods__["y"] = setY
    if _newclass: 
            x = property(x, x)
            y = property(y, y)

    __swig_destroy__ = _libdelaunator.delete_Coordinates
    __del__ = lambda self: None
Coordinates_swigregister = _libdelaunator.Coordinates_swigregister
Coordinates_swigregister(Coordinates)

class Vertex(Coordinates):
    __swig_setmethods__ = {}
    for _s in [Coordinates]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vertex, name, value)
    __swig_getmethods__ = {}
    for _s in [Coordinates]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vertex, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libdelaunator.new_Vertex(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _libdelaunator.delete_Vertex
    __del__ = lambda self: None

    def neighbourCount(self):
        return _libdelaunator.Vertex_neighbourCount(self)

    def take(self, arg2, arg3=None):
        return _libdelaunator.Vertex_take(self, arg2, arg3)

    def giveVirtualVerticesTo(self, arg2):
        return _libdelaunator.Vertex_giveVirtualVerticesTo(self, arg2)

    def forget(self, arg2):
        return _libdelaunator.Vertex_forget(self, arg2)

    def getID(self):
        return _libdelaunator.Vertex_getID(self)

    def getObjectCount(self):
        return _libdelaunator.Vertex_getObjectCount(self)

    def getObjects(self, arg2=0):
        return _libdelaunator.Vertex_getObjects(self, arg2)

    def getFirstObject(self):
        return _libdelaunator.Vertex_getFirstObject(self)

    def getEdge(self):
        return _libdelaunator.Vertex_getEdge(self)

    def setEdge(self, e):
        return _libdelaunator.Vertex_setEdge(self, e)

    def isNeighbourOf(self, arg2):
        return _libdelaunator.Vertex_isNeighbourOf(self, arg2)

    def have(self, arg2):
        return _libdelaunator.Vertex_have(self, arg2)

    def __coordinates__(self):
        return _libdelaunator.Vertex___coordinates__(self)
Vertex_swigregister = _libdelaunator.Vertex_swigregister
Vertex_swigregister(Vertex)

class Edge(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Edge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Edge, name)
    __repr__ = _swig_repr

    def __init__(self, arg2=None, arg3=None, arg4=None, arg5=None, arg6=True):
        this = _libdelaunator.new_Edge(arg2, arg3, arg4, arg5, arg6)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _libdelaunator.delete_Edge
    __del__ = lambda self: None

    def distanceTo(self, *args):
        return _libdelaunator.Edge_distanceTo(self, *args)

    def squareDistanceTo(self, *args):
        return _libdelaunator.Edge_squareDistanceTo(self, *args)

    def coordOnTheStrictRight(self, arg2):
        return _libdelaunator.Edge_coordOnTheStrictRight(self, arg2)

    def coordOnTheRight(self, arg2):
        return _libdelaunator.Edge_coordOnTheRight(self, arg2)

    def coordOnTheStrictLeft(self, arg2):
        return _libdelaunator.Edge_coordOnTheStrictLeft(self, arg2)

    def coordOnTheLeft(self, arg2):
        return _libdelaunator.Edge_coordOnTheLeft(self, arg2)

    def originVertex(self):
        return _libdelaunator.Edge_originVertex(self)

    def destinVertex(self):
        return _libdelaunator.Edge_destinVertex(self)

    def oppositeEdge(self):
        return _libdelaunator.Edge_oppositeEdge(self)

    def nextLeftEdge(self):
        return _libdelaunator.Edge_nextLeftEdge(self)

    def prevLeftEdge(self):
        return _libdelaunator.Edge_prevLeftEdge(self)

    def nextRightEdge(self):
        return _libdelaunator.Edge_nextRightEdge(self)

    def prevRightEdge(self):
        return _libdelaunator.Edge_prevRightEdge(self)

    def rotLeftEdge(self):
        return _libdelaunator.Edge_rotLeftEdge(self)

    def rotRightEdge(self):
        return _libdelaunator.Edge_rotRightEdge(self)

    def leftFace(self):
        return _libdelaunator.Edge_leftFace(self)

    def rightFace(self):
        return _libdelaunator.Edge_rightFace(self)

    def isVisible(self):
        return _libdelaunator.Edge_isVisible(self)

    def isExternal(self):
        return _libdelaunator.Edge_isExternal(self)

    def getID(self):
        return _libdelaunator.Edge_getID(self)

    def length(self):
        return _libdelaunator.Edge_length(self)

    def squareLength(self):
        return _libdelaunator.Edge_squareLength(self)

    def middle(self):
        return _libdelaunator.Edge_middle(self)

    def setOriginVertex(self, v):
        return _libdelaunator.Edge_setOriginVertex(self, v)

    def setOppositeEdge(self, e):
        return _libdelaunator.Edge_setOppositeEdge(self, e)

    def setNextLeftEdge(self, e):
        return _libdelaunator.Edge_setNextLeftEdge(self, e)

    def setLeftFace(self, f, ttl=3):
        return _libdelaunator.Edge_setLeftFace(self, f, ttl)

    def setVisibility(self, v):
        return _libdelaunator.Edge_setVisibility(self, v)
    __swig_setmethods__["passing"] = _libdelaunator.Edge_passing_set
    __swig_getmethods__["passing"] = _libdelaunator.Edge_passing_get
    if _newclass:
        passing = _swig_property(_libdelaunator.Edge_passing_get, _libdelaunator.Edge_passing_set)
Edge_swigregister = _libdelaunator.Edge_swigregister
Edge_swigregister(Edge)

class Face(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Face, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Face, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3=True):
        this = _libdelaunator.new_Face(arg2, arg3)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _libdelaunator.delete_Face
    __del__ = lambda self: None

    def computeInternalValues(self):
        return _libdelaunator.Face_computeInternalValues(self)

    def collideAt(self, arg2):
        return _libdelaunator.Face_collideAt(self, arg2)

    def circumcircleContainCoords(self, arg2):
        return _libdelaunator.Face_circumcircleContainCoords(self, arg2)

    def isVisible(self):
        return _libdelaunator.Face_isVisible(self)

    def getEdge(self):
        return _libdelaunator.Face_getEdge(self)

    def getEdge1(self):
        return _libdelaunator.Face_getEdge1(self)

    def getEdge2(self):
        return _libdelaunator.Face_getEdge2(self)

    def getEdge3(self):
        return _libdelaunator.Face_getEdge3(self)

    def getP1(self):
        return _libdelaunator.Face_getP1(self)

    def getP2(self):
        return _libdelaunator.Face_getP2(self)

    def getP3(self):
        return _libdelaunator.Face_getP3(self)

    def getID(self):
        return _libdelaunator.Face_getID(self)

    def circumcenter(self):
        return _libdelaunator.Face_circumcenter(self)

    def circumcircleRadius(self):
        return _libdelaunator.Face_circumcircleRadius(self)

    def setEdge(self, arg2):
        return _libdelaunator.Face_setEdge(self, arg2)

    def setVisibility(self, v):
        return _libdelaunator.Face_setVisibility(self, v)
Face_swigregister = _libdelaunator.Face_swigregister
Face_swigregister(Face)

class VirtualVertex(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VirtualVertex, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VirtualVertex, name)
    __repr__ = _swig_repr

    def __init__(self, arg2=None):
        this = _libdelaunator.new_VirtualVertex(arg2)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _libdelaunator.delete_VirtualVertex
    __del__ = lambda self: None

    def confoundedWithAnotherObject(self):
        return _libdelaunator.VirtualVertex_confoundedWithAnotherObject(self)

    def vertex(self):
        return _libdelaunator.VirtualVertex_vertex(self)

    def id(self):
        return _libdelaunator.VirtualVertex_id(self)

    def coordinates(self):
        return _libdelaunator.VirtualVertex_coordinates(self)

    def setVertex(self, arg2):
        return _libdelaunator.VirtualVertex_setVertex(self, arg2)

    def confundedNeighbors(self):
        return _libdelaunator.VirtualVertex_confundedNeighbors(self)

    def directNeighbors(self):
        return _libdelaunator.VirtualVertex_directNeighbors(self)

    def neighborsAt(self, arg2, arg3=0):
        return _libdelaunator.VirtualVertex_neighborsAt(self, arg2, arg3)

    def nearerNeighbors(self, arg2):
        return _libdelaunator.VirtualVertex_nearerNeighbors(self, arg2)
VirtualVertex_swigregister = _libdelaunator.VirtualVertex_swigregister
VirtualVertex_swigregister(VirtualVertex)


_libdelaunator.VERTEX_FINDER_MODE_RANDOM_swigconstant(_libdelaunator)
VERTEX_FINDER_MODE_RANDOM = _libdelaunator.VERTEX_FINDER_MODE_RANDOM

_libdelaunator.VERTEX_FINDER_MODE_FIRST_swigconstant(_libdelaunator)
VERTEX_FINDER_MODE_FIRST = _libdelaunator.VERTEX_FINDER_MODE_FIRST

_libdelaunator.VERTEX_FINDER_MODE_MIDDLE_swigconstant(_libdelaunator)
VERTEX_FINDER_MODE_MIDDLE = _libdelaunator.VERTEX_FINDER_MODE_MIDDLE

_libdelaunator.VERTEX_FINDER_MODE_LAST_swigconstant(_libdelaunator)
VERTEX_FINDER_MODE_LAST = _libdelaunator.VERTEX_FINDER_MODE_LAST
class Triangulation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Triangulation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Triangulation, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4, arg5, arg6=VERTEX_FINDER_MODE_LAST):
        this = _libdelaunator.new_Triangulation(arg2, arg3, arg4, arg5, arg6)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _libdelaunator.delete_Triangulation
    __del__ = lambda self: None

    def addVertexAt(self, *args):
        return _libdelaunator.Triangulation_addVertexAt(self, *args)

    def vertexAt(self, *args):
        return _libdelaunator.Triangulation_vertexAt(self, *args)

    def moveVertex(self, *args):
        return _libdelaunator.Triangulation_moveVertex(self, *args)

    def moveVertexTo(self, v, c):
        return _libdelaunator.Triangulation_moveVertexTo(self, v, c)

    def delVertex(self, v):
        return _libdelaunator.Triangulation_delVertex(self, v)

    def mergeVertex(self, v, v_destroyed):
        return _libdelaunator.Triangulation_mergeVertex(self, v, v_destroyed)

    def coordinateCorrection(self, arg2):
        return _libdelaunator.Triangulation_coordinateCorrection(self, arg2)

    def unittests(self):
        return _libdelaunator.Triangulation_unittests(self)

    def representation(self):
        return _libdelaunator.Triangulation_representation(self)

    def getEdges(self):
        return _libdelaunator.Triangulation_getEdges(self)

    def getVertices(self):
        return _libdelaunator.Triangulation_getVertices(self)

    def getVirtualVertices(self):
        return _libdelaunator.Triangulation_getVirtualVertices(self)

    def getVerticeCount(self):
        return _libdelaunator.Triangulation_getVerticeCount(self)

    def getXmin(self):
        return _libdelaunator.Triangulation_getXmin(self)

    def getXmax(self):
        return _libdelaunator.Triangulation_getXmax(self)

    def getYmin(self):
        return _libdelaunator.Triangulation_getYmin(self)

    def getYmax(self):
        return _libdelaunator.Triangulation_getYmax(self)

    def epsilon(self):
        return _libdelaunator.Triangulation_epsilon(self)

    def getFinderMode(self):
        return _libdelaunator.Triangulation_getFinderMode(self)

    def setFinderMode(self, arg2):
        return _libdelaunator.Triangulation_setFinderMode(self, arg2)

    def have(self, arg2):
        return _libdelaunator.Triangulation_have(self, arg2)

    def haveCorner(self, arg2):
        return _libdelaunator.Triangulation_haveCorner(self, arg2)

    def collideAt(self, arg2):
        return _libdelaunator.Triangulation_collideAt(self, arg2)

    def opt_isdebug(self):
        return _libdelaunator.Triangulation_opt_isdebug(self)

    def opt_follow_search(self):
        return _libdelaunator.Triangulation_opt_follow_search(self)
Triangulation_swigregister = _libdelaunator.Triangulation_swigregister
Triangulation_swigregister(Triangulation)

class Delaunator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Delaunator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Delaunator, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4, arg5, arg6=VERTEX_FINDER_MODE_LAST):
        this = _libdelaunator.new_Delaunator(arg2, arg3, arg4, arg5, arg6)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _libdelaunator.delete_Delaunator
    __del__ = lambda self: None

    def addVirtualVertex(self, *args):
        return _libdelaunator.Delaunator_addVirtualVertex(self, *args)

    def delVirtualVertex(self, arg2):
        return _libdelaunator.Delaunator_delVirtualVertex(self, arg2)

    def movVirtualVertex(self, *args):
        return _libdelaunator.Delaunator_movVirtualVertex(self, *args)

    def virtualVertexAt(self, *args):
        return _libdelaunator.Delaunator_virtualVertexAt(self, *args)

    def virtualVerticesAt(self, *args):
        return _libdelaunator.Delaunator_virtualVerticesAt(self, *args)

    def clear(self):
        return _libdelaunator.Delaunator_clear(self)

    def freeAll(self):
        return _libdelaunator.Delaunator_freeAll(self)

    def unittests(self):
        return _libdelaunator.Delaunator_unittests(self)

    def representation(self):
        return _libdelaunator.Delaunator_representation(self)

    def objectCount(self):
        return _libdelaunator.Delaunator_objectCount(self)

    def getXmin(self):
        return _libdelaunator.Delaunator_getXmin(self)

    def getXmax(self):
        return _libdelaunator.Delaunator_getXmax(self)

    def getYmin(self):
        return _libdelaunator.Delaunator_getYmin(self)

    def getYmax(self):
        return _libdelaunator.Delaunator_getYmax(self)

    def epsilon(self):
        return _libdelaunator.Delaunator_epsilon(self)

    def distanceMax(self):
        return _libdelaunator.Delaunator_distanceMax(self)

    def getFinderMode(self):
        return _libdelaunator.Delaunator_getFinderMode(self)

    def setFinderMode(self, arg2):
        return _libdelaunator.Delaunator_setFinderMode(self, arg2)

    def virtualVertices(self):
        return _libdelaunator.Delaunator_virtualVertices(self)

    def edges(self):
        return _libdelaunator.Delaunator_edges(self)

    def haveVertex(self, arg2):
        return _libdelaunator.Delaunator_haveVertex(self, arg2)

    def collideAt(self, arg2):
        return _libdelaunator.Delaunator_collideAt(self, arg2)

    def opt_isdebug(self):
        return _libdelaunator.Delaunator_opt_isdebug(self)

    def opt_follow_search(self):
        return _libdelaunator.Delaunator_opt_follow_search(self)
Delaunator_swigregister = _libdelaunator.Delaunator_swigregister
Delaunator_swigregister(Delaunator)

class TrianguledObject(object):
        """
        Object defined by Delaunator module for simplify using of it.
        This is like an abstract class : no real code need to have pure Trianguled Object defined.
        Correct use is to use objects that inherits from this class.
        """
        # TrianguledObject references all trianguled objects by dict virtual vertex => TrianguledObject
        refs = {None:None}


# CONSTRUCTOR #################################################################
        def __init__(self, delaunator = None, coords = None):
                """
                @param delaunator a valid reference to a delaunay triangulation, or None (default is None)
                @param coords (x,y) tuple, position in the triangulation, or None (default is None)
                @note that self will attach itself if and only if given args are not None, and coords are valid in delaunator
                """
                if delaunator is not None:
                        delaunator.addTrianguledObject(self, coords)



# PUBLIC METHOD ###############################################################
        def coordinates(self):
                return self.virtual_vertex.coordinates()


        def squareDistanceTo(self, tri_obj):
                """
                @param tri_obj a trianguled object instance
                @return square distance to this object, according to coordinates of self and tri_obj
                @warning the distance returned is the squared distance. Useful for compare distances without slow call to sqrt()
                """
                return self.coordinates().squareDistanceTo(tri_obj.coordinates())


        def distanceTo(self, tri_obj):
                """
                @param tri_obj a trianguled object instance
                @return distance to this object, according to coordinates of self and tri_obj
                """
                return self.coordinates().distanceTo(tri_obj.coordinates())


# ACCESSORS ###################################################################
        @property
        def virtualConfundedNeighbors(self):
                """
                @return list of VirtualVertex, that are confunded neighbors of self
                @note confunded neighbors share the same Vertex instance.
                """
                return (_ for _ in self.virtual_vertex.confundedNeighbors() if self.virtual_vertex.id() !=  _.id())


        @property
        def confundedNeighbors(self):
                """
                @return list of TrianguledObject, that are confunded neighbors of self
                @note confunded neighbors share the same Vertex instance.
                """
                return (TrianguledObject.of(_) for _ in self.virtual_vertex.confundedNeighbors() if self.virtual_vertex.id() !=  _.id())


        @property
        def directNeighbors(self):
                """
                @return list of direct neighbors of self
                @note direct neighbors have no sense out of mathematical definition of delaunay triangulation, because its just objects that are directly connected to self by an edge.
                """
                return (TrianguledObject.of(_) for _ in self.virtual_vertex.directNeighbors())


        def nearerNeighbors(self, nb_neighbors, post_filter=lambda t: True):
                """
                @param nb_neighbors a positiv integer
                @param post_filter a callable that return True or False and take a TrianguledObject in argument.
                @return list that contain a maximum of nb_neighbors neighbors in nearer-first order.
                @note if post_filter provided, filtering happen after constitution of the list.
                """
                return (TrianguledObject.of(_) for _ in self.virtual_vertex.nearerNeighbors(nb_neighbors) if self.virtual_vertex.id() !=  _.id() and post_filter(TrianguledObject.of(_)))


        def neighborsAt(self, max_distance, min_distance = 0, predicat=lambda t: True):
                """
                @param max_distance number that give the limit distance
                @param min_distance number that give the low limit. No low limit if equal to zero (default value is zero)
                @param predicat a callable that return True or False and take a TrianguledObject in argument.
                @return list that contain the TrianguledObject that are at max_distance at most of self, min_distance at least of self, and that respect the given predicat
                """
                return (TrianguledObject.of(_) for _ in self.virtual_vertex.neighborsAt(max_distance, min_distance) if self.virtual_vertex.id() !=  _.id() and predicat(TrianguledObject.of(_)))


        def virtualVertex(self):
                """
                @return virtual vertex associated with this instance
                """
                return self.virtual_vertex



# PREDICAT ####################################################################
        def inTriangulation(self):
                """
                @return True iff associated with a triangulation.
                """
                return self.virtual_vertex is not None



# CLASS METHOD ################################################################
        @staticmethod
        def of(virtual_vertex):
                return TrianguledObject.refs[virtual_vertex.id()] if virtual_vertex is not None else None




def trianguledObjects(self):
        """
        @return iterable of objects
        """
        return (TrianguledObject.of(_) for _ in self.virtualVertices())
# this function is now part of Delaunator API
Delaunator.trianguledObjects = trianguledObjects




def addTrianguledObject(self, tri_obj, coords):
        """
        @param tri_obj TrianguledObject to add
        @param coords (x,y) where tri_obj will be place
        @return the id of tri_obj in self instance, or None iff coords invalid
        """
        added = None
        # transform user coords into Coordinates object
        if not isinstance(coords, Coordinates):
                coords = Coordinates(*coords)
        # add the trianguled object
        if tri_obj is not None and coords is not None:
                tri_obj.virtual_vertex = self.addVirtualVertex(coords)
                if tri_obj.virtual_vertex is not None: # all is ok, object is added !
                        added = tri_obj.virtual_vertex.id()
                        TrianguledObject.refs[added] = tri_obj
        return added
# this function is now part of Delaunator API
Delaunator.addTrianguledObject = addTrianguledObject




def delTrianguledObject(self, tri_obj):
        """
        @param tri_obj the TrianguledObject that will be forget
        Detach tri_obj of self. Destroy associated VirtualVertex.
        """
        if tri_obj.virtual_vertex is not None:
                # delete references between virtual vertex and Trianguled object
                del TrianguledObject.refs[tri_obj.virtual_vertex.id()]
                self.delVirtualVertex(tri_obj.virtual_vertex)
                tri_obj.virtual_vertex = None
# this function is now part of Delaunator API
Delaunator.delTrianguledObject = delTrianguledObject




def movTrianguledObject(self, tri_obj, coords):
        """
        @param tri_obj the TrianguledObject that will be moved
        @param coords that will be added to current tri_obj coordinates
        """
        # transform user coords into Coordinates object
        if not isinstance(coords, Coordinates):
                coords = Coordinates(*coords)
        # do the move
        self.movVirtualVertex(tri_obj.virtual_vertex, coords)
# this function is now part of Delaunator API
Delaunator.movTrianguledObject = movTrianguledObject





def trianguledObjectAt(self, coords, precision=None):
        """
        @param tri_obj the TrianguledObject that will be moved
        @param coords that will be added to current tri_obj coordinates
        @return TrianguledObject find at given coords, or None if not found
        """
        # transform precision in a valid value
        if precision is None:
                precision = self.epsilon()
        # transform user coords into Coordinates object
        if not isinstance(coords, Coordinates):
                coords = Coordinates(*coords)
        # do the looking
        return TrianguledObject.of(self.virtualVertexAt(coords, precision))
# this function is now part of Delaunator API
Delaunator.trianguledObjectAt = trianguledObjectAt



class VirtualVertexList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VirtualVertexList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VirtualVertexList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libdelaunator.VirtualVertexList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libdelaunator.VirtualVertexList___nonzero__(self)

    def __bool__(self):
        return _libdelaunator.VirtualVertexList___bool__(self)

    def __len__(self):
        return _libdelaunator.VirtualVertexList___len__(self)

    def pop(self):
        return _libdelaunator.VirtualVertexList_pop(self)

    def __getslice__(self, i, j):
        return _libdelaunator.VirtualVertexList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libdelaunator.VirtualVertexList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libdelaunator.VirtualVertexList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libdelaunator.VirtualVertexList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libdelaunator.VirtualVertexList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libdelaunator.VirtualVertexList___setitem__(self, *args)

    def append(self, x):
        return _libdelaunator.VirtualVertexList_append(self, x)

    def empty(self):
        return _libdelaunator.VirtualVertexList_empty(self)

    def size(self):
        return _libdelaunator.VirtualVertexList_size(self)

    def clear(self):
        return _libdelaunator.VirtualVertexList_clear(self)

    def swap(self, v):
        return _libdelaunator.VirtualVertexList_swap(self, v)

    def get_allocator(self):
        return _libdelaunator.VirtualVertexList_get_allocator(self)

    def begin(self):
        return _libdelaunator.VirtualVertexList_begin(self)

    def end(self):
        return _libdelaunator.VirtualVertexList_end(self)

    def rbegin(self):
        return _libdelaunator.VirtualVertexList_rbegin(self)

    def rend(self):
        return _libdelaunator.VirtualVertexList_rend(self)

    def pop_back(self):
        return _libdelaunator.VirtualVertexList_pop_back(self)

    def erase(self, *args):
        return _libdelaunator.VirtualVertexList_erase(self, *args)

    def __init__(self, *args):
        this = _libdelaunator.new_VirtualVertexList(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _libdelaunator.VirtualVertexList_push_back(self, x)

    def front(self):
        return _libdelaunator.VirtualVertexList_front(self)

    def back(self):
        return _libdelaunator.VirtualVertexList_back(self)

    def assign(self, n, x):
        return _libdelaunator.VirtualVertexList_assign(self, n, x)

    def resize(self, *args):
        return _libdelaunator.VirtualVertexList_resize(self, *args)

    def insert(self, *args):
        return _libdelaunator.VirtualVertexList_insert(self, *args)

    def pop_front(self):
        return _libdelaunator.VirtualVertexList_pop_front(self)

    def push_front(self, x):
        return _libdelaunator.VirtualVertexList_push_front(self, x)

    def remove(self, x):
        return _libdelaunator.VirtualVertexList_remove(self, x)

    def unique(self):
        return _libdelaunator.VirtualVertexList_unique(self)

    def reverse(self):
        return _libdelaunator.VirtualVertexList_reverse(self)

    def sort(self):
        return _libdelaunator.VirtualVertexList_sort(self)

    def merge(self, x):
        return _libdelaunator.VirtualVertexList_merge(self, x)
    __swig_destroy__ = _libdelaunator.delete_VirtualVertexList
    __del__ = lambda self: None
VirtualVertexList_swigregister = _libdelaunator.VirtualVertexList_swigregister
VirtualVertexList_swigregister(VirtualVertexList)

# This file is compatible with both classic and new-style classes.


