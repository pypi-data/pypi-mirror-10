""".. module:: Swoop

.. moduleauthor:: Steven Swanson (swanson@cs.ucsd.edu)

Swoop is a library of Python objects for representing and manipulating
Cadsoft Eagle board, schematic, and library files used in designing printed
circuit boards (PCBs).  It parses an input Eagle file, creates a internal
representation data structure that represents the file's contents,
provides accessors and mutators to query, read, and modify those contents, and
generates valid Eagle files as output.

Swoop uses several different objects to represent and manipulate Eagle files.

 1. **EagleFilePart** Swoop use a tree of :class:`EagleFilePart` objects to represent an Eagle file.  There many subclasses of :class:`EagleFilePart` that correspond to different parts of the file.

 2. **Utility classes**  Most notably :class:`From` which provides a fluent interface for Eagle files and :class:`EagleFilePartVisitor` which implements a visitor framework for Swoop data structures.

 3. **Exception classes** For reporting errors.

In addition, Swoop provides a :doc:`several mechanisms  </ExtendingSwoop>` for extending its functionality. 

Because the Swoop data structures map (almost) directly to Eagle file
structures, some understanding of the Eagle file format is necessary in order
to use Swoop.  However, it is possible to use Swoop without understanding all
the details the format.  The eagle.dtd that ships with Eagle (in the 'doc'
directory) is a good place to start learning about the file format.  If you are
familiar with Eagle, the file format is relatively easy to understand.

The code for most of Swoop is autogenerated by a Python script called
:code:`GenerateSwoop.py` using the Jinja templating system.

Swoop was created by the `NVSL <http://nvsl.ucsd.edu/>`_ at  `UCSD <http://www.ucsd.edu/>`_ as part of the  `Gadgetron project <http://nvsl.ucsd.edu/index.php?path=projects/gadget>`_. 
"""
from lxml import etree as ET
import eagleDTD
import StringIO
import logging as log
import copy
import os
import re
supportedVersions = ["6.5.0", "6.6.0", "7.0.0", "7.1.0", "7.2.0"]

class EagleFormatError(Exception):
    """
    An error occured durig parsing an input file or generating an output file.
    """
    def __init__(self, text=""):
        self.text = text
    def __str__(self):
        return self.text

def NotImplemented(s):
    raise NotImplementedError(s)

class SwoopError (Exception):
    """
    An internal error occurred.
    """
    def __init__(self, text):
        self.text = text
    def __str__(self):
        return self.text

class EagleFilePart(object):

    """

    Base class for all eagle tag objects.  It provides fallback implementations
    of core features, facilities for navagating the part tree, and provides the
    :code:`parent` attribute.
    

    """
    
    def __init__(self):
        self.parent = None

    def get_file(self):
        """
        Get the :class:`EagleFile` containing this object.

        :rtype: :class:`EagleFile`

        """
        r = self.get_root()
        if isinstance(r, EagleFile):
            return r
        else:
            return None

    def get_class_for_tag(self, tag):
        if self.get_file() is None:
            raise NotImplementedError("Creation of children from file-less EFPs is not supported")
        # print "---"
        # print type(self.get_file()).__name__
        # print type(self.get_file()).class_map["library"]
        # print "+++"
        return type(self.get_file()).class_map[tag]
    
    def get_parent(self):
        """
        Get this object's parent.

        :returns: The object's parent.
        :rtype: :class:`EagleFilePart`
        """
        return self.parent

    def detach(self):
        """
        Remove this :class:'EagleFilePart` from its parent.

        :returns: :code:`self`
        :rtype: :class:`EagleFilePart`
        
        """
        
        self.parent.remove_child(self)
        return self
    
    @classmethod
    def _from_et (cls, et):
        """
        Parse the part from an Element Tree

        """
        raise NotImplementedError()
    
    def get_et ():
        """
        Generate an element tree that represents the :code:`EagleFilePart`.

        :rtype: :class:`etree.ElementTree`

        """
        raise NotImplementedError()

    def get_root(self):
        """ 
        Find the root of this :class:`EagleFilePart` tree.

        :rtype: :class:`EagleFilePart`

        """
        if self.get_parent() is not None:
            return self.get_parent().get_root()
        else:
            return self

    def clone(self):
        """
        Clone the :class:`EagleFilePart`.  It should be identical to the orginial, except that the parent should be :code:`None`.

        :rtype: :class:`EagleFilePart`
        """
        raise NotImplementedError()

    def get_children(self):
        """
        Return a list of all the :code:`EagleFilePart` children of this :code:`EagleFilePart`

        :rtype: List of :class:`EagleFilePart` objects 

        """
        raise NotImplementedError()

    def check_sanity(self):
        """
        Perform a (recursive) sanity check on this :code:`EagleFilePart`
        
        :rtype: :code:`None`
        """
        for i in self.get_children():
            if i.parent != self:
                raise SwoopError("Parent pointer mismatch.  Child = " + str(i) + "; child.parent = " + str(i.parent) + "; Parent = " + str(self) )
            i.check_sanity()

    def with_type(self,t):
        """
        Filter this :code:`EagleFilePart` object based on its type.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if self is an instance of type :code:`t` and :code:`None` otherwise.  This is useful in combination with :class:`From` object.
        
        :param t: The type to check for.
        :returns: :code:`self` if self is an instance of type :code:`t` and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        return self if isinstance(self, t) else None

    def make_from(self):
        """
        Create a a :class:`From` object containing this object.

        :returns: :class:`From` object containing this object.
        :rtype: :class:`From`

        """
        return From(self)
    
def parseByType(efp, attrType, s):

    if attrType == "None_is_empty_string":
        if s is None:
            r = ""
        else:
            r = s
    elif s is not None:
        if attrType == "str":
            r = s
        elif attrType == "int":
            r = int(s)
        elif attrType == "float":
            r = float(s)
        elif attrType == "bool":

            if s.upper() in ["YES"]:
                r = True
            elif s.upper() in ["NO"]:
                r = False
            else:
                raise SwoopError("Invalid eagle bool value '" + s +"' in child of " + str(efp))
        elif attrType == "constant_bool":
            r = (s != "no")
        elif attrType == "layer_string":
            r = efp.get_file().layer_number_to_name(int(s))
        else:
            raise SwoopError("Unknown attr type '" + attrType + "'")
        assert r is not None
    else:
        r = None
    
    return r

def unparseByType(efp, attrType, v):
    if attrType == "None_is_empty_string":
        if v == "":
            r = None
        else:
            r = v
    elif v is not None:
        if attrType == "str":  # Doing nothing to strings lets us handle weird
                               # unicode characters.
            r = v 
        elif attrType in ["int", "float"]:
            r = str(v)
        elif attrType == "bool":
            if v:
                return "yes"
            else:
                return "no"
        elif attrType == "constant_bool":
            if not v:
                r = "no"
            else:
                r = None
        elif attrType == "layer_string":
            r = str(efp.get_file().layer_name_to_number(v))
        else:
            raise SwoopError("Unknown attr type '" + attrType + "'")

        if attrType != "constant_bool":
            assert r is not None
    else:
        r = None
    
    return r



class EagleFile(EagleFilePart):
    """

    Base class for Eagle files.  It handle opening, parsing, validation, associated errors, writing output, and the mapping between layer numbers and layer names.

    This class also serves a factory class for :class:`EagleFilePart` objects.
    Calling the :meth:`new_*()` methods on an :class:`EagleFile`, yields new
    objects that include any Swoop extensions that have been applied.  

    """

    # A validator for element tree representations of eagle files.
    DTD = None if eagleDTD.DTD is None else ET.DTD(StringIO.StringIO(eagleDTD.DTD)) 

    class_map = {}
    boardFileType = None
    schematicFileType = None
    libraryFileType = None
    
    #{% for tag in tags %}
    def new_{{tag.classname}}(self):
        return type(self).class_map["{{tag.tag}}"]()
    #{% endfor %}        

    def __init__ (self):
        """
        Construct an empty :class:`EagleFile`.
        """
        EagleFilePart.__init__(self)
        self.filename= None
        self.root = None
        self.tree = None
        self.layers = {}
        self.layersByName = {}

    @classmethod
    def get_schematic_file_type(cls):
        if cls.schematicFileType is None:
            return SchematicFile
        else:
            return cls.schematicFileType

    @classmethod
    def get_board_file_type(cls):
        if cls.boardFileType is None:
            return BoardFile
        else:
            return cls.boardFileType
        
    @classmethod
    def get_library_file_type(cls):
        if cls.libraryFileType is None:
            return LibraryFile
        else:
            return cls.libraryFileType
        
        
    def validate(self):
        """
        Check that this file conforms to the eagle DTD. Return True, if it does, False otherwise.

        :rtype: Bool
        """
        et = self.get_et()
        if EagleFile.DTD is not None:
            v = EagleFile.DTD.validate(et)
        else:
            log.warning("Can't validate Swoop tree.  DTD is missing.")
            v = True;
        
        if not v:
            log.warning("Eagle file opened as '" + str(self.filename) +"' is invalid: " + str(EagleFile.DTD.error_log.filter_from_errors()[0]))
        else:
            log.info("Eagle file opened as '" + str(self.filename) +"' parsed to valid Eagle data.")

        for t in et.findall(".//*"):
            for a in t.attrib.values():
                if a == str(None):
                    log.warning("Eagle file opened as '" + str(self.filename) +"' has 'None' attribute value")
                    return False
        
        return v

    @classmethod
    def open(cls,filename, bestEffort = True):
        """
        Loads a Eagle file from a .sch, .lbr, or .brd file.  A synonym for :meth:`EagleFile.from_file`
        
        :param filename: Filename to load.
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        return cls.from_file(filename, bestEffort)

    @classmethod
    def from_file (cls, filename, bestEffort = True):
        """
        Loads a Eagle file from a .sch, .lbr, or .brd file.  A synonym for :meth:`EagleFile.open`

        :param filename: Filename to load. 
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        try:
            tree = ET.parse(filename)
        except ET.XMLSyntaxError as e:
            raise EagleFormatError("Eagle file '" + str(filename) +"' doesn't look like XML eagle file.  Try resaving with a newer version of eagle.")
        
        root = tree.getroot()

        if EagleFile.DTD is not None:
            v = EagleFile.DTD.validate(root)
        else:
            log.warning("Can't validate input file.  DTD is missing.")
            v = True;

        if not v:
            if bestEffort:
                log.warning("Eagle file opened as '" + str(filename) +"' is invalid on disk: " + str(EagleFile.DTD.error_log.filter_from_errors()[0]))
            else:
                raise EagleFormatError("Eagle file opened as '" + str(filename) +"' is invalid on disk: " + str(EagleFile.DTD.error_log.filter_from_errors()[0]))
                
        if filename[-4:] == ".sch":
            ef = cls.get_schematic_file_type()._from_et(root, None)
        elif filename[-4:] == ".brd":
            ef = cls.get_board_file_type()._from_et(root, None)
        elif filename[-4:] == ".lbr":
            ef = cls.get_library_file_type()._from_et(root, None, filename)
        else:
            raise SwoopError("Unknown file suffix: '" + filename[-4:] + "'")
        ef.filename = filename
        ef.root = root
        ef.tree = tree

        if ef.get_version() not in supportedVersions:
            if bestEffort:
                log.warning("Eagle file opened as '" + str(filename) +"' is not one of " + str(supportedVersions) + ".  Doing our best.")
            else:
                raise EagleFormatError("Eagle file opened as '" + str(filename) +"' is not one of " + str(supportedVersions) + ".  Chickening out.")
                
        ef.check_sanity()
        return ef

    @staticmethod
    def from_file_by_type(filename, ftype):
        n = EagleFile.from_file(filename)
        if not isinstance(n, ftype):
            raise SwoopError("File is '" + filename + "' is not " + ftype.__name__)
        return n

    def write (self, file, check_sanity=True, dtd_validate=True):
        """
        Exports the Schematic to an EAGLE schematic file.
        
        :param file: Filename or file-like object for output.
        :param check_sanity:  Perform semantic sanity checks before output.
        :param dtd_validate:  Check for DTD compliance before output.
        """

        header="""<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE eagle SYSTEM "eagle.dtd">
"""
        if type(file) is str:
            f = open(file, "w")
            filename = file
        else:
            f = file
            filename = None
            
        if check_sanity:
            self.check_sanity()
        if dtd_validate and not self.validate():
            if filename is not None:
                f = open(filename + ".broken.xml", "w")
                f.write(header + ET.tostring(ET.ElementTree(self.get_et()),pretty_print=True))
            raise SwoopError("Swoop structure does not validate" + str(EagleFile.DTD.error_log.filter_from_errors()[0]))
        else:
            f.write(header+ET.tostring(ET.ElementTree(self.get_et()),pretty_print=True))

    def add_layer (self, layer):
        """
        Add a layer to this file.
        
        :param layer: The :class:`Layer` to add.

        :rtype: :code:`None`

        """
        assert isinstance(layer, Layer)

        self.layers[int(layer.number)] = layer
        self.layersByName[layer.name] = layer
        layer.parent = self

    def get_layers(self):
        """
        Get a map of names to Layer objects
        
        :rtype: Map of :code:`EagleFilePart` objects keyed by layer name.

        """
        return self.layersByName

    def get_layersByNumber(self):
        """
        Get a map of numbers to Layer objects.

        :rtype: Map of :code:`EagleFilePart` objects keyed by layer number.
        """
        return self.layers

    # def get_flippedLayer(self, l):
    #     if (isinstance(l, str)):
    #         origName = l
    #         if l[0] == "t":
    #             l = "b" + l[1:]
    #         elif l[0] == "b":
    #             l = "t" + l[1:]
    #         elif l == "Top":
    #             l = "Bottom"
    #         elif l == "Bottom":
    #             l = "Top"
    #         if l not in self.layersByName:
    #             raise SwoopError("Tried to flip layer '" + origName + "', but '" + l + "' doesn't exist")
    #         return name
    #     elif (isinstance(l,int)):
    #         if l in self.layers:
    #             return self.get_flippedLayer(self, self.layers[l]).number
    #         else:
    #             raise SwoopError("Can't find layer number " + number)
    #     elif (isinstance(l,Layer)):
    #         if l.name in self.layersByName:
    #             return self.layersByName[get_flippedLayer(l.name)]
    #         else:
    #             raise SwoopError("Can't find layer '" + l.name +"' in this file")

    def parse_layer_number(self, num):

        if num is None:
            return None
        return self.layer_number_to_name(num)

    def unparse_layer_name(self, name):
        if name is None:
            return None
        return self.layer_name_to_number(name)
    
    def layer_number_to_name(self, num):
        """
        Given a layer number, return the name.

        :rtype: :class:`Layer` 
        """
        n = int(num)
        if n not in self.layers:
            raise SwoopError("No layer number " + str(n) +" in " + str(self.filename))
        return self.layers[n].name

    def layer_name_to_number(self, name):
        """
        Given a layer name, return the number.

        :rtype: :class:`Layer` 
        """
        assert type(name) is str
        if name not in self.layersByName:
            raise SwoopError("No layer named '" + name + "' in " + str(self.filename))
        return self.layersByName[name].number

    def remove_layer(self, layer):
        """
        Remove a layer.
        
        :param layer: :class:`Layer` object, layer name, or layer number that should be deleted.
        
        :rtype: :code:`None`
        """
        if type(layer) is str:
            l = self.layersByName[layer]
            self.remove_layer(l)
        elif type(layer) is int:
            l = self.layers[layer]
            self.remove_layer(l)
        elif isinstance(layer, Layer):
            self.layersByName[layer.name].parent = None
            del self.layersByName[layer.name]
            del self.layers[int(layer.number)]
        else:
            raise SwoopError("Invalid layer spec: " + str(layer))
            
    # def get_manifest(self):
    #     raise NotImplementedError("Manifest for " + str(type(self)))

    def find_library_by_name(self, l):
        """
        Lookup a library by name and return it.

        :param l: Library name.
        :rtype: :class:`Library` or :code:`None` if the library is not present.
        """
        return self.libraries.get(l)

def Mixin(mixin, prefix, base=EagleFile):
    """Extend Swoop by adding a mixin to every class.

    This function creates a new subclasses of every class Swoop uses to
    represent an Eagle file (including the file types).  The names of the new
    classes are prefixed with :code:`prefix` and they all inherit from the
    original class and :code:`mixin`.

    :param mixin: Mixin class.  Its constructor should take no arguments.
    :param prefix: Prefix for the class name.  It'll be prepended to the names of all the Swoop classes.
    :param base: Starting point for the extension.  This should either be :class:`Swoop.EagleFile` or a class returned by a previous call to this function.
    :returns: A new subclass of :code:`base` that can be used just like :class:`EagleFile`
    :rtype: A class.

    """
    def Extend(C, m, name):
        class T(C,m):
            class_map={}
            def __init__(self):
                C.__init__(self)
                m.__init__(self)
        T.__name__ = name
        return T

    n = Extend(base,mixin, prefix + base.__name__)
    #print n.class_map.get("library")
    for i in base.class_map:
        n.class_map[i] = Extend(base.class_map[i], mixin, prefix + base.class_map[i].__name__)

    n.boardFileType = Extend(base.get_board_file_type(),         mixin, prefix + base.get_board_file_type().__name__)
    n.schematicFileType = Extend(base.get_schematic_file_type(), mixin, prefix + base.get_schematic_file_type().__name__)
    n.libraryFileType = Extend(base.get_library_file_type(),     mixin, prefix + base.get_library_file_type().__name__)

    n.boardFileType.class_map = copy.copy(n.class_map)
    n.schematicFileType.class_map = copy.copy(n.class_map)
    n.libraryFileType.class_map = copy.copy(n.class_map)

    # print "there " + str(n)
    # print "there " + str(n.boardFileType)
    # print "there " + str(n.schematicFileType)
    # print "there " + str(n.libraryFileType)
    # print "there " + str(n.libraryFileType.class_map)
    #print "here" + str(n.class_map.get("library"))
    return n

    
def smartAddSubTags(root, path):

    """
    Add tags as need to create a container for the contents of an xpath.

    :rtype: :code:`None`
    """
    pathSegments = path.split("|")[0].replace("./","").split("/")
    target = root
    for p in pathSegments[0:-1]:
        new_target = target.find(p)
        if new_target is None:
            target = ET.SubElement(target,p)
        else:
            target = new_target
    return target

def filter_list(l, match_type, attrs):
    r = []
    if attrs is None:
        attrs = {}
        
    for efp in l:
        match = True
        for k in attrs:
            if type(attrs[k]) in [str,int,float]:
                match = match and getattr(efp,k) == attrs[k]
            elif callable(attrs[k]):
                match = match and attrs[k](efp)
            else:
                assert False
        if match_type is not None:
            match = match and isinstance(efp, match_type)
        if match:
            r.append(efp)
    return r

def matching(e):
    """Helper function for filtering :class:`From` objects.  The filter allows
    items to pass based on whether they match the regex :code:`e`.  For
    example, this will print the number of packages with names starting with
    "FOO" in a library.

    .. code-block:: python
    
    print(From(library).
          get_packages().
          with_name(matching("^FOO.*")).count()

    """
    return lambda x: re.match(e, x) is not None

def not_matching(e):
    """Helper function for filtering :class:`From` objects.  The filter allows
    items to pass based on whether they *don't* match the regex :code:`e`.  
    
    For example, this will print the number of packages with names not starting
    with "FOO" in a library.

    .. code-block:: python
    
    print(From(library).
          get_packages().
          with_name(not_matching("^FOO.*")).count()

    """
    return lambda x: re.match(e, x) is None


class From(object):
    """An ordered collection of (usually) :class:`EagleFilePart` objects.  Invoke
    a method on a :class:`From` object, invokes the same method with the same
    arguments on all the objects it holds.  The results are placed in a new
    :class:`From` object that is returned.

    :class:`From` objects also provide several utility functions for
    accessing, filtering, mapping, and reducing their contents.

    You can combine the contents of the two :class:`From` objects with the
    :code`+` operator.
    
    :class:`From` objects are iterable.

    """
    def __init__(self, *args):
        r = []
        for i in args:
            if type(i) is list:
                r += i
            elif type(i) == From:
                r += i.efps
            else:
                r += [i]
        self.efps = r

    def __str__(self):
        return "From: " + str(self.efps)

    def __repr__(self):
        return self.__str__()

    def __len__(self):
        return len(self.efps)

    def __getitem__(self,n):
        return self.efps[n]

    def __add__(self, rhs):
        return self.append(rhs)
    
    def __getattr__(self, name):
        def wrapper(*args, **kargs):
            r = []
            for i in self.efps:
                t = getattr(i,name)(*args,**kargs)
                if type(t) is dict:
                    r += t.values()
                elif type(t) is list:
                    r += t
                elif t is None:
                    pass
                else:
                    r.append(t)
            return From(r)
        return wrapper

    def append(self, l):
        """
        Merge the contents of :code:`l` into this :class`From` object.

        :param l: Python list of :class:`EagleFilePart` objects, a :class:`From` object, or an :class:`EagleFilePart` object.
        :returns: This :class:`From` object with the new items added.
        :rtype: :class:`From` 
        """
        if type(l) is list:
            self.efps += i
        elif type(l) == From:
            self.efps += l.efps
        else:
            self.efps += [l]
        return self

    def unpack(self):
        """
        Return the contents of the :class:`From` object as a list.
        
        :returns: A list containing the contents of the :class:`From`
        :rtype:  List
        """
        return self.efps

    def first(self):
        """
        Return the first item in the :class:`From` object.  If the :class:`From` is empty, raise an :class:`IndexError` exception.
        
        :returns: The first item in the :class:`From`
        :rtype:  Varies
        :throws: :class:`IndexError`
        """
        return self.efps[0]

    def filtered_by(self, func):
        """
        Filter the :class:`From`.  Similar to the builtin :code:`filter` method.
        
        :returns: A :class:`From` object contain the elements, :code:`x` for which :code:`func(x)` return :code:`True`
        """
        return From([x for x in self.efps if func(x)])

    def unique(self):
        """
        Remove duplicate elements from the :class:`From`
        
        :returns: A :class:`From` object contain the unique elements in this :class:`From`.
        """
        return From(list(set(self.efps)))

    def count(self):
        """
        Count the elements in the :class:`From`

        :returns: The number of elements.
        :rtype: int
        """
        return len(self.efps)

    def sort(self, cmp=None, key=None, reverse=False):
        """
        Sort the :class:`From` object.  Similar to the builtin :code:`sorted` method (and takes the same arguments).

        :param cmp: Comparison function.
        :param key: A key accessor function.
        :param reverse: If :code:`True` sort in reverse order.
        
        :returns: A sorted :class:`From`
        """
        return From(sorted(self.efps, cmp, key, reverse))

    def map(self, func):
        """
        Apply a function to the elments of this :class:`From` and return a :class:`From` containing the results.  Similar to the builtin :code:`map` function.
        
        :param func: The function to apply.
        :returns: A :class:`From` containing the results.
        """
        return From(map(func, self.efps))

    def apply(self, func):
        """Apply a function to the elments of this :class:`From` and return a
        :class:`From` containing the results.  Similar to the builtin
        :code:`map` function.  A synonym for :meth:`From.map`.
        
        :param func: The function to apply.
        :returns: A :class:`From` containing the results.

        """
        return From(map(func, self.efps))

    
    def reduce(self, func, init=None):
        """
        Reduce the elments of this :class:`From` and return the result.  Similar to the builtin :code:`reduce` function.
        
        :param func: The function to apply.
        :param init: The starting value for the reduction.
        :returns: The reduce result
        :rtype: Varies
        """
        if init is None:
            return reduce(func, self.efps)
        else:
            return reduce(func, self.efps, init)

def from_file(filename):
    return From(EagleFile.from_file(filename))

class EagleFilePartVisitor(object):
    """A visitor utility class for :class:`EagleFile` objects.  

    The class traverses a subtree of :class:`EagleFilePart` objects in
    depth-first order.  Subclasses can define *vistor* methods of the form
    :code:`*X*_pre()` and :code:`*X*_post()` that will be called in pre-order
    and post-order during the traversal.  If a subclass doesn't define a
    particular an :class:`EagleFilePart` subclass, :meth:`default_pre` and
    :meth:`default_pre` will be used instead.

    Subclasses can also override :meth:`visitFilter` and
    :meth:`decendFilter` to control which :class:`EagleFilePart` the visitor
    invokes the visitor methods on and which :class:`EagleFilePart` the visitor
    decends into.  By default, both visitor methods are called on all
    :class:`EagleFilePart` objects and in the visitor always decends.

    The :meth:`go` method start execution.  It also returns :code:`self` so
    you can easily apply accessor functions after execution.  You can also call
    :meth:`visit` on an :class:`EagleFilePart` object to visit the subtree
    underneath it

    For example, here's a simple visitor that counts the total number of
    :class:`EagleFileParts` in a file and, separately, the number of
    :class:`Element` objects:
    
    .. code-block:: python

        class Counter(SwoopTools.EagleFilePartVisitor):
            def __init__(self, root=None):
                SwoopTools.EagleFilePartVisitor.__init__(self,root)
                self.count = 0;
                self.elementCount = 0
                self.layerCount = 0
            def default_pre(self, efp):
                self.count += 1
            def Element_pre(self, e):
                self.count += 1
                self.elementCount += 1
    
    And you can use it like so:

    .. code-block:: python

        from Swoop import *
        from SwoopTools import *
        ef = EagleFile.from_file(my_file)
        c = Counter(ef)
        print "The file has this many parts: " + str(c.go().count)
        print "There are this many Elements: " + str(c.elementCount)

    """

    def __init__(self, root=None):
        self.root = root

    def go(self):
        """
        Start the visiting process.
        
        :rtype: :code:`self`
        """
        self.visit(self.root)
        return self
    
    def visitFilter(self, e):
        """Predicate that determines whether to call the visit functions on this
        :class:`EagleFilePart`.  The default implementation returns ``True``.
        
        :param e: The :class:`EagleFilePart` to be visited.
        :rtype:   ``Bool``

        """
        return True

    def decendFilter(self, e):
        """Predicate that determines whether to decend into the subtree rooted at ``e``.  The default implementation returns ``True``.
        
        :param e: The root :class:`EagleFilePart`.
        :rtype:   ``Bool``

        """
        return True


    def default_pre(self,e):
        """Default pre-order visitor function.

        This method can return a value that will be passed to the corresponding
        post-order visitor function, making it easy to pass state between the
        two.

        The default implementation does nothing and returns ``None``
        
        :param e: The  :class:`EagleFilePart` being visited.
        :rtype: Any

        """
        return None

    def default_post(self,e, context):
        """Default post-order visitor function.  The default implementation does nothing.
        
        :param e: The  :class:`EagleFilePart` being visited.
        :param context: The value returned by corresponding pre-order visitor.
        :rype: ``None``
        """
        pass

    def visit(self, efp):
        """ Run this visitor on the subtree rooted at ``efp``.
        
        :param efp: The :class:`EagleFilePart` at the root of the tree.
        :rtype:  ``self``
        """
        if self.visitFilter(efp):
            context = efp.accept_preorder_visitor(self)

        if self.decendFilter(efp):
            for e in efp.get_children():        
                self.visit(e)
                
        if self.visitFilter(efp):
            context = efp.accept_postorder_visitor(self, context)

        return self


#{% for tag in tags %}

#{%if not tag.customchild %}
#{% set classname = tag.classname %}
#{% else %}
#{% set classname = "Base_" + tag.classname %}
#{%endif%}

class {{classname}}({{tag.baseclass}}):
    """
    Class representing the contents of a <{{tag.tag}}> tag in Eagle files.

    Attributes:

    #{%for a in tag.attrs %}
    * :code:`{{a.accessorName}}`

    #{%endfor%}

    #{%if tag.hasCollections %}

    Collections:

    #{%for a in tag.singletons %}
    * :code:`{{a.accessorName}}`: Singleton {{a.get_contained_type_list_doc_string("or")}} object. 

    #{%endfor%}

    #{%for a in tag.lists %}
    * :code:`{{a.accessorName}}`: List of {{a.get_contained_type_list_doc_string("and")}} objects.

    #{%endfor%}

    #{%for a in tag.maps %}
    * :code:`{{a.accessorName}}`: Map of {{a.get_contained_type_list_doc_string("and")}} objects indexed by their :code:`{{a.mapkey}}`.


    #{%endfor%}

    #{%endif%}
    """
    def __init__(self):
        """
        Construct an empty :class:`{{classname}}` object.
        """
        {{tag.baseclass}}.__init__(self)
        
        #{%for a in tag.attrs %}
        self.{{a.name}}=None
        #{%endfor%}
        #{%for l in tag.lists %}
        self.{{l.name}}=[]
        #{%endfor%}
        #{%for m in tag.maps %}
        self.{{m.name}}={}
        #{%endfor%}
        #{%for s in tag.singletons %}
        self.{{s.name}}=None
        #{%endfor%}

        #{%if tag.preserveTextAs != "" %}
        self.{{tag.preserveTextAs}} = ""
        #{%endif%}

        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`{{tag.classname}}` from a :code:`{{tag.tag}}` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`{{tag.classname}}`
        """
        ## Call the constructor
        n = cls()
        n. _init_from_et(root,parent)
        return n
            
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`{{tag.classname}}` from a :code:`{{tag.tag}}` element.  This is useful if you have a subclass of :class:`{{tag.classname}}` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`{{tag.classname}}`
        """
            
        if root.tag != "{{tag.tag}}":
            raise EagleFormatError("Tried to create {{tag.tag}} from " + root.tag)

        #{%for a in tag.attrs%}
        self.{{a.name}}={{a.parse}}(parent, "{{a.vtype}}", root.get("{{a.xmlName}}"))
        #{%endfor%}

        self.parent = parent

        ### populate the maps by searching for elements that match xpath and generating objects for them.
        
        #{%for m in tag.maps%}
        for c in root.xpath("{{m.xpath}}"):
            self.add_{{m.accessorName}}(self.get_class_for_tag(c.tag)._from_et(c, self))
        #{%endfor%}

        ### Do the same for the lists

        #{%for l in tag.lists %}
        for c in root.xpath("{{l.xpath}}"):
            self.add_{{l.accessorName}}(self.get_class_for_tag(c.tag)._from_et(c,self))
        #{%endfor%}

        ### And the singletons
        
        #{%for s in tag.singletons %}
        x = root.xpath("{{s.xpath}}")
        if len(x) is not 0:
            self.set_{{s.accessorName}}(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
        #{%endfor%}

        ### And, finally, if the objects wants the text from the tag.
        
        #{%if tag.preserveTextAs != "" %}
        self.{{tag.preserveTextAs}} = root.text
        #{% endif %}


    def sortkey(self):
        #{% if tag.dontsort %}
        return ""
        #{%elif tag.sortattr != None %}
        return self.{{tag.sortattr}};
        #{%else%}
        r = ""
        #{% for a in tag.attrs %}
        r = r + str(self.{{a.name}})
        #{% endfor %}
        return r
        #{% endif %}

    def get_et(self):
        """
        Generate a <{{tag.tag}}> element tree for a :class:`{{tag.classname}}`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        r = ET.Element("{{tag.tag}}")

        ### Set the tag attributes 
        
        #{%for a in tag.attrs%}

        ## Unparse the values.

        v = {{a.unparse}}(self, "{{a.vtype}}", self.{{a.name}})

        ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
        if v is not None:
            r.set("{{a.xmlName}}", v)
        #{%if a.required %}
        else:
            r.set("{{a.xmlName}}", "")
        #{%endif%}

        #{%endfor%}

        ### process the sections in order.  They have to be in section order,
        ### because eagle files are order dependent.
        
        #{%for l in tag.sections%}

        ## For some tags, Eagle generates empty tags when there's no contant
        ## rather than just leaving the tag out.  We mark these with
        ## Tag.requireTag in GenerateSwoop.py and force their generation
        ## here.
        
        #{%if l.requireTag %}
        smartAddSubTags(r, "{{l.xpath}}")
        #{%endif%}

        #{%if l.type == "List" %}

        ## add a list.

        if len(self.{{l.name}}) is not 0:
            target = smartAddSubTags(r, "{{l.xpath}}")
            # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
            target.extend([i.get_et() for i in sorted(self.{{l.name}},key=lambda x: x.sortkey())])
        #{%elif l.type == "Map" %}

        ## add a map.
        
        if len(self.{{l.name}}) is not 0:
            target = smartAddSubTags(r, "{{l.xpath}}")
            # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
            target.extend([i.get_et() for i in sorted(self.{{l.name}}.values(),key=lambda x: x.sortkey())])
        #{%else%}

        ## or add a singleton.
        
        if self.{{l.name}} is not None:
            target = smartAddSubTags(r, "{{l.xpath}}")
            target.append(self.{{l.name}}.get_et())
        #{%endif%}
        #{%endfor%}

        ## set the text, if its needed.
        
        #{%if tag.preserveTextAs != "" %}
        r.text = self.{{tag.preserveTextAs}}
        #{% endif %}
        return r

    def clone(self):
        """
        Recursively clone this :code:`{{tag.classname}}`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`{{tag.classname}}`
        """
        n = copy.copy(self)
        #{%for m in tag.maps%}
        n.{{m.name}} = {}
        for x in self.{{m.name}}.values():
            n.add_{{m.accessorName}}(x.clone())
        #{%endfor%}
        #{%for l in tag.lists %}
        n.{{l.name}} = []
        for x in self.{{l.name}}:
            n.add_{{l.accessorName}}(x.clone())
        #{%endfor%}
        #{%for s in tag.singletons %}
        if n.{{s.name}} is not None:
            n.{{s.name}} = self.{{s.name}}.clone()
        #{%endfor%}
        n.parent = None
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "{{tag.classname}}_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "{{tag.classname}}_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)
        
    ### Getters/Setters for attribute values

    #{%for a in tag.attrs%}
    def get_{{a.accessorName}}(self):
        """ Return the value of :code:`{{a.name}}` for this :class:`{{tag.classname}}`.  This corresponds to the :code:`{{a.name}}` attribute of a :code:`<{{tag.tag}}>` in an Eagle file.
        
        :rtype: :code:`{{a.vtype}}`
        """
        return self.{{a.name}}

    def set_{{a.accessorName}}(self,v):
        """ Set the value of :code:`{{a.name}}` for this  :class:`{{tag.classname}}`.  This corresponds to the :code:`{{a.name}}` attribute of a :code:`<{{tag.tag}}>` in an Eagle file.

        :param v: :class:`EagleFilePart` to set.

        :rtype: :code:`self`
        """
        self.{{a.name}} = v
        return self

    def with_{{a.accessorName}}(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`{{a.name}}`.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`{{a.name}}` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_{{a.accessorName}}()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.{{a.name}} == v else None
        elif callable(v):
            return self if v(self.{{a.name}}) else None


    #{%endfor%}

    ##### Lookup functions that return EFPs instead of just attribute values.
    
    #{%for a in tag.attrs%}
    #{%if a.lookupEFP != None %}
    def find_{{a.accessorName}}(self):
        """Find the :class:`{{a.lookupEFP[0]}}` object refered to by the :code:`{{a.name}}` attribute of this object.  This is like
        :meth:`get_{{a.name}}`, except it returns the :class:`{{a.lookupEFP[0]}}` object instead of its name.
        
        :returns: The object
        :rtype: :class:`{{a.lookupEFP[0]}}`

        """
        f = {{a.lookupEFP[1]}}
        return f(self, self.{{a.name}})
    #{%endif%}
    #{%endfor%}
    
    #{%if tag.preserveTextAs != "" %}
    def with_{{tag.preserveTextAs}}(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`{{tag.preserveTextAs}}`.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`{{tag.preserveTextAs}}` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_{{tag.preserveTextAs}}()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.{{tag.preserveTextAs}} == v else None
        elif callable(v):
            return self if v(self.{{tag.preserveTextAs}}) else None
        else:
            raise SwoopError("Illegal type passed to with_{{tag.preserveTextAs}}")
    #{% endif %}


    
    ### Adder/getter/lookup for lists
    
    #{%for l in tag.lists%}
    #{%if not l.suppressAccessors %}
    def add_{{l.accessorName}}(self, s):
        """ Add a {{l.get_contained_type_list_doc_string()}} to the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.

        :param s: The {{l.get_contained_type_list_doc_string("or")}} to add.
        :rtype: :code:`self`
        """
        self.{{l.name}}.append(s)
        s.parent = self
        return self

    def get_nth_{{l.accessorName}}(self, n):
        """ get then nth {{l.get_contained_type_list_doc_string("or")}} object from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :param n: Index of the item to return.

        :rtype: {{l.get_contained_type_list_doc_string()}} object
        """
        return self.{{l.name}}[n]

    def get_{{l.name}}(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`{{l.name}}` list of {{l.get_contained_type_list_doc_string("or")}} objects for this :class:`{{tag.classname}}`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of {{l.get_contained_type_list_doc_string("and")}} objects
        :rtype: List of {{l.get_contained_type_list_doc_string("and")}} objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.{{l.name}}

    def clear_{{l.name}}(self):
        """
        Remove all the {{l.get_contained_type_list_doc_string("and")}} objects from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :rtype: :code:`self`
        """
        for efp in self.{{l.name}}:
            efp.parent = None
        self.{{l.name}} = []
        return self

    def remove_{{l.accessorName}}(self, efp):
        """
        Remove a {{l.get_contained_type_list_doc_string()}} from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :param efp: The {{l.get_contained_type_list_doc_string("or")}} object to remove.

        :rtype: :code:`self`
        """
        self.{{l.name}} = [x for x in self.{{l.name}} if x != efp]
        efp.parent = None
        return self

    #{%else%}
    # {{l.name}} accessor supressed
    #{%endif%}
    #{%endfor%}

        ### Add, lookup, and get for maps
    #{%for m in tag.maps%}
    #{%if not m.suppressAccessors %}
    def add_{{m.accessorName}}(self, s):
        """ Add a {{m.get_contained_type_list_doc_string()}} to the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.

        :param s: The {{m.get_contained_type_list_doc_string()}} to add.
        :rtype: :code:`self`
        """
        self.{{m.name}}[s.{{m.mapkey}}] = s
        s.parent = self
        return self

    def get_nth_{{m.accessorName}}(self, n):
        """ get then nth {{m.get_contained_type_list_doc_string("or")}} object from the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.
        
        :param n: Index of the item to return.

        :rtype: {{m.get_contained_type_list_doc_string()}} object
        """
        return self.{{m.name}}.values()[n]

    def get_{{m.accessorName}}(self, key):
        """ Lookup and return a {{m.get_contained_type_list_doc_string("or")}} from the :code:`{{m.name}}` of  this :class:`{{tag.classname}}`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`{{m.mapkey}}` of the {{m.get_contained_type_list_doc_string("or")}} objects.

        :rtype: A {{m.get_contained_type_list_doc_string()}} object or :code:`None`, if there is no such item.
        """
        return self.{{m.name}}.get(key)


    def get_{{m.name}}(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`{{m.name}}` map of {{m.get_contained_type_list_doc_string("or")}} objects for this :class:`{{tag.classname}}`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of {{m.get_contained_type_list_doc_string("and")}} objects
        :rtype: List of {{m.get_contained_type_list_doc_string("and")}} objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return self.{{m.name}}.values()
        

    def clear_{{m.name}}(self):
        """
        Remove all the {{m.get_contained_type_list_doc_string("and")}} objects from the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.
        
        :rtype: :code:`self`
        """
        for efp in self.{{m.name}}.values():
            efp.parent = None
        self.{{m.name}} = {}
        return self

    def remove_{{m.accessorName}}(self, efp):
        """
        Remove a {{m.get_contained_type_list_doc_string()}} from the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.
        
        :param efp: The {{m.get_contained_type_list_doc_string("or")}} object to remove.

        :rtype: :code:`self`
        """
        del self.{{m.name}}[efp.{{m.mapkey}}]
        efp.parent = None
        return self
    #{%endif%}
    #{%endfor%}


    
    ### Getter/Setter for singletons.

    #{%for l in tag.singletons%}
    #{%if not l.suppressAccessors %}
    def set_{{l.accessorName}}(self, s):
        """ Set the {{l.get_contained_type_list_doc_string()}} for this  :class:`{{tag.classname}}`.

        :param s: {{l.get_contained_type_list_doc_string()}} to set.
        :rtype: :code:`self`
        """
        if self.{{l.name}} is not None:
            self.{{l.name}}.parent = None
        self.{{l.name}} = s
        if self.{{l.name}}.parent is not None:
            self.{{l.name}}.parent = self
        return self

    def get_{{l.accessorName}}(self):
        """ Get the {{l.accessorName}} from this :class:`{{tag.classname}}`.
        
        :rtype: {{l.get_contained_type_list_doc_string()}} object
        """
        return self.{{l.name}}

    #{%endif%}
    #{%endfor%}
    
    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        #{%for l in tag.lists%}
        r = r + self.{{l.name}}
        #{%endfor%}

        #{%for m in tag.maps%}
        r = r + self.{{m.name}}.values()
        #{%endfor%}
        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        #{%for m in tag.maps%}
        try:
            self.remove_{{m.accessorName}}(efp)
        except:
            pass
        #{%endfor%}
        #{%for l in tag.lists%}
        try:
            self.remove_{{l.accessorName}}(efp)
        except:
            pass
        #{%endfor%}
        #{%for s in tag.singletons%}
        if self.get_{{s.accessorName}} == efp:
            self.set_{{s.accessorName}}(None)
        #{%endfor%}

    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print indent + str(self.__class__.__name__)
        for c in self.get_children():
            c.dump(indent + "   ")

EagleFile.class_map["{{tag.tag}}"] = {{classname}}
         
#{% endfor %}


class Part (Base_Part):
    """Extra functions for Parts.  Sanity checks, and facilities for find the
    symbols, devices, etc. for a part.

    """
    def __init__(self):
        Base_Part.__init__(self)

    # def is_child(self, f):
    #     if f == "schematic":
    #         return False
    #     else:
    #         return EagleFilePart.is_child(self,f)

    def check_sanity(self):
        #assert self.get_device() is not None

        try:
            assert self.find_library() is not None
        except Exception as e:
            raise SwoopError("Library '" + self.library +  "' missing for " + str(self.name))
        
        try:
            assert self.find_deviceset() is not None
        except Exception as e:
            raise SwoopError("DeviceSet '" + self.find_library().name + ":" + self.deviceset + "' missing for " + str(self.name))

        try:
            assert self.find_device() is not None
        except Exception as e:
            raise SwoopError("Device '" + self.find_library().name + ":" + self.find_deviceset().name + ":" + self.device + "' missing for " + str(self.name))
        
        EagleFilePart.check_sanity(self)
        
         
    def find_library(self):
        """
        Get the library that contains this part
        """
        lib = self.get_root().libraries.get(self.library)
        return lib

    def find_deviceset(self):
        """
        Get the deviceset for this part.
        """
        lib = self.find_library();
        deviceset = lib.devicesets.get(self.deviceset)
        return deviceset
        
    def find_device(self):
        """
        Get the library entry for this part
        """
        deviceset = self.find_deviceset()
        device = deviceset.devices.get(self.device)
        return device

    def find_technology(self):
        """
        Get the library entry for this part
        """
        device = self.find_device()
        tech = device.technologies.get(self.technology)
        return tech

    def set_device(self, library=None, deviceset=None, device=None):
        if library is not None:
            self.library = library
        if deviceset is not None:
            self.deviceset = deviceset
        if device is not None:
            self.device = device
        return self

        
    def find_package(self):
        """
        Get the library entry for this part
        """
        device = self.find_device();
        lib = self.find_library();
        if device.package is not None:
            package = lib.packages.get(device.package);
        else:
            package = None
        return package
    

    # def get_library_attributes(self):
    #     """
    #     Get attribute values for this part that come from the library.
    #     """
    #     return {k:v for (k,v) in self.attributes.iteritems() if v.from_library}

    def set_attribute(self,name, value):
        if name in self.attributes:
            self.attributes[name].set_value(value)
        else:
            self.add_attribute(Attribute().
                               set_name(name).
                               set_value(value).
                               set_in_library(False))
        return self


    # def get_attribute(self,name):
    #     return self.attributes.get(name).value

    # def remove_attribute(self,name):
    #     self.attributes[name].parent = None
    #     del self.attributes[name]

EagleFile.class_map["part"] = Part


class Attribute (Base_Attribute):
    """Extra functionality for Attributes.  Attributes are used in many places in
    eagle files and they require different attributes in some cases.

    """
    def __init__(self):
        Base_Attribute.__init__(self)
        self.in_library = False

    def __str__(self):
        return self.name + " = '" + self.value + "' [const=" + str(self.constant) + ";lib=" + str(self.from_library) +"]";


    @classmethod
    def _from_et (cls, attribute_root, parent):
        n = Attribute()
        n. _init_from_et(attribute_root, parent)
        
        if attribute_root.getparent().tag == "technology":
            from_library = True;
        elif attribute_root.getparent().tag == "part":
            from_library = False
        elif attribute_root.getparent().tag == "instance":
            from_library = False
        elif attribute_root.getparent().tag == "element":
            from_library = False
        elif attribute_root.getparent().tag == "attributes":
            from_library = False
        else:
            raise SwoopError("Unexpectedly found attribute in '" + attribute_root.getparent().tag +"' tag.")

        n.in_library = from_library
        return n

    def set_in_library(self, v):
        self.in_library = v
        return self
    
    def get_in_libbrary(self):
        return self.in_library()

    def get_et (self):
        n = Base_Attribute.get_et(self)
        
        if not self.in_library:
            if "constant" in n.attrib:
                del n.attrib["constant"]

        return n

EagleFile.class_map["attribute"] = Attribute

#### Extra methods for DeviceSets

def convertToExternal(self):
    """
    This converts the :class:`Deviceset` into an external deviceset.  This means that it
    has no associated package.  It can, however, have attributes, and those
    are stored in the "" device.  You can't just delete all the packages,
    since you'd lose the attributes.  This copies them from the first
    package.
    """
    if len(self.get_devices()) > 0:
        d = self.get_devices()[0]
        self.clear_devices()
        d.set_name("").set_package(None).clear_connects()
    else:
        d = (Device().
             set_name("").
             set_package(None).
             add_technology(Technology().
                            set_name("")))
    self.add_device(d)

    From(d).get_technologies().add_attribute(Attribute().set_name("_EXTERNAL_"))

setattr(Deviceset, "convertToExternal", convertToExternal)
        
class LibraryFile(Base_LibraryFile):
    def __init__(self):
        Base_LibraryFile.__init__(self)
        
    @classmethod
    def _from_et (cls,et, parent, filename):
        """
        Loads a Library file from an ElementTree.Element representation.
        """
        r = cls()
        r. _init_from_et(et, parent)
        if r.get_library().name is None:
            r.get_library().set_name(os.path.basename(filename)[:-4])
        return r

    # def get_library_copy(self):
    #     return copy.deepcopy(self.library)

    
#print EagleFile.class_map
