# set up python environment
import os
import sys
import glob
import shutil
import warnings
from argparse import ArgumentParser
from subprocess import Popen, STDOUT
from os.path import dirname, isfile, join, realpath, split

from runtime import opts
from matmodlab.utils.misc import load_file
from product import ROOT_D, BLD_D, PLATFORM, TEST_D, PKG_D

# --- check prereqs
(major, minor, micro, relev, ser) = sys.version_info
if (major != 3 and major != 2) or (major == 2 and minor < 7):
    errors.append('python >= 2.7 required')
    errors.append('  {0} provides {1}.{2}.{3}'.format(
        sys.executable, major, minor, micro))

errors = []
# --- numpy
try: import numpy
except ImportError: errors.append('numpy not found')

# --- scipy
try: import scipy
except ImportError: errors.append('scipy not found')

# check prerequisites
if errors:
    sys.exit('*** error: matmodlab could not run due to the '
             'following errors:\n  {0}'.format('\n  '.join(errors)))

commands = ('build', 'clean', 'config', 'helper', 'run', 'test', 'view')

usage = '''\
usage: mml [-h|help] <command> [<args>]

The mml commands are:
           Launch the (empty) matmodlab gui
  build    Build fortran libraries
  clean    Clean simulation and build files generated by matmodlab
  config   Run the cofiguration tool
  run      Run a simulation
  test     Run tests
  view     Launch the matmodlab viewer

See 'mml help <command>' to read about a specific subcommand.
'''

def envins(E, x, i=0):
    e = os.getenv(E, '').split(os.pathsep)
    e.insert(i, x)
    return os.pathsep.join(e)

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    # if no arguments given, exit
    if not argv:
        x = 'view'

    else:
        # get first argument, check if help requested
        x, argv = argv[0], argv[1:]
        if x in ('-h', '--help'):
            sys.exit(usage)

        # check for command specific help
        if x == 'help':
            if not argv:
                sys.exit(usage)
            x, argv = argv[0], ['-h']

        # at this point, x is a mml command.  get the specific file to load
        if x not in commands:
            sys.exit('mml: "{0}" is not a mml command.  See "mml -h".'.format(x))

    if x != 'run':
        sys.argv = ['mml {0}'.format(x)] + argv
        if x == 'view':
            import matmodlab.viewer.main as module
        elif x == 'help':
            sys.exit(run(['-h']))
        elif x == 'build':
            import matmodlab.mmd.builder as module
        elif x == 'clean':
            sys.exit(clean(argv=argv))
        elif x == 'config':
            import matmodlab.mmd.configurer as module
        elif x == 'test':
            try:
                import pytest
            except ImportError:
                raise SystemExit('pytest required to run tests')
            sys.path.insert(0, ROOT_D)
            sys.argv[0] = 'py.test'
            # if the first arguments are file or directories, done modify
            # sys.argv further, otherwise put in the tests directory
            for item in sys.argv[1:]:
                if os.path.exists(item):
                    break
            else:
                sys.argv.insert(1, TEST_D)
            sys.exit(pytest.main())

        sys.exit(module.main(argv=argv))

    # to get to this point, the command was 'run'.
    assert x == 'run'
    sys.exit(run(argv))

def run(argv):

    prog = "mml run"
    desc = """{0}: run a matmodlab simulation script in the matmodlab
    environment. Simulation scripts can be run directly by the python
    interpreter if {1} is on your PYTHONPATH.""".format(prog, ROOT_D)
    p = ArgumentParser(prog=prog, description=desc)
    p.add_argument("-v", default=opts.verbosity,
       type=int, help="Verbosity [default: %(default)s]")
    p.add_argument("--debug", default=opts.debug, action="store_true",
       help="Debug mode [default: %(default)s]")
    p.add_argument("--sqa", default=opts.sqa, action="store_true",
       help="SQA mode [default: %(default)s]")
    p.add_argument("--switch", metavar=("MATX", "MATY"),
       default=None, nargs=2,
       help=("Run with MATY instead of MATX, if present"
             "(not supported by all models) [default: %(default)s]"))
    p.add_argument("-B", metavar="MATERIAL",
        help="Wipe and rebuild MATERIAL before running [default: %(default)s]")
    p.add_argument("-V", default=False, action="store_true",
        help="Launch results viewer on completion [default: %(default)s]")
    p.add_argument("-j", "--nprocs", type=int, default=opts.nprocs,
        help="Number of simultaneous jobs [default: %(default)s]")
    p.add_argument("-E", action="store_true", default=False,
        help="Do not use matmodlabrc configuration file [default: False]")
    p.add_argument("-W", choices=["std","all","error"], default=opts.warn,
        help="Warning level [default: %(default)s]")
    p.add_argument("-w", action="store_true", default=False,
        help=("Wipe and rebuild material in Material factory before "
              "running [default: %(default)s]"))
    p.add_argument("source",
        help="Python source file [default: %(default)s]")

    args = p.parse_args(argv)

    filename = args.source
    if not isfile(filename):
        filename = filename.rstrip('.') + '.py'
    if not isfile(filename):
        sys.exit('*** error: mml run: {0}: expected first argument to be '
                 'a file name'.format(argv[0]))

    if args.E:
        opts.set_default_options()

    # set runtime options
    opts.debug = args.debug
    opts.sqa = args.sqa
    if args.nprocs != 1:
        print 'warning: multiprocessing not finished, nprocs set to 1.'
        args.nprocs = 1
    opts.nprocs = args.nprocs
    opts.verbosity = args.v
    opts.rebuild_mat_lib = args.w
    opts.warn = args.W

    # model switching
    switch = []
    if args.switch:
        switch.append(args.switch)
    switch.extend(opts.switch)
    opts.switch = switch

    if args.V:
        opts.viz_on_completion = True

    if args.B:
        name = args.B.strip()
        verbosity = 3 if args.v > 1 else 0
        if os.path.isfile(os.path.join(PKG_D, "{0}.so".format(name))):
            # removing is sufficient since the material class will attempt
            # to build non-existent materials
            os.remove(os.path.join(PKG_D, "{0}.so".format(name)))

    if not opts.Wall:
        warnings.simplefilter("ignore")

    # run this python file, make sure to set __name__ to __main__
    gdict = globals()
    gdict['__name__'] = '__main__'
    code = compile(open(filename, 'r').read(), '<string>', 'exec')
    exec(code) in gdict

    if args.v and not opts.gui_mode:
        from matmodlab.utils.quotes import write_random_quote
        write_random_quote()

    return

def clean(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    usage = '''\
usage: mml-clean [-h]

Remove files generated by matmodlab (.pyc, .o, .so, .a, build, etc.)
'''

    def printc(path):
        string = 'file' if os.path.isfile(path) else 'directory'
        sys.stdout.write('removing {0} {1}\n'.format(string, path))
    def remove(a):
        if os.path.isfile(a):
            os.remove(a)
        elif os.path.isdir(a):
            shutil.rmtree(a)

    p = ArgumentParser(prog='mml clean', usage=usage)
    args = p.parse_args(argv)

    sys.stdout.write('cleaning matmodlab...\n')
    sys.stdout.flush()
    exts = ('.pyc', '.o', '.con', '.a', '-f2pywrappers2.f90',
            'module.c', '.so', '.log', '.math', '.out', '.exo', '.dbx',
            'TestResults.{0}'.format(PLATFORM))
    remove(BLD_D)
    for (dirname, dirs, files) in os.walk(ROOT_D):
        if dirname.endswith('.eval'):
            printc(dirname)
            remove(dirname)
            del dirs[:]
            continue
        for ext in exts:
            for f in glob.glob('{0}/*{1}'.format(dirname, ext)):
                printc(f)
                remove(f)
    sys.stdout.write('done\n')
if __name__ == '__main__':
    main()
