# Python code for State Space Models in the library PySSM
# Copyright (C) 2010  Chris Strickland

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 or version 3 of the
# License.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# ----------------------------------------------------------------------
# Python code for state space models with regressors
# ----------------------------------------------------------------------

import numpy as np
import unifilter as uni
import filter as stdfilter
from ssm_base import System, FilterBase, SimSmootherBase
import filterreg

# ----------------------------------------------------------------------


class SystemReg(System):
    """
    Class to store system matricies for SSM with regressors. The SSM
    is assumed to be generated by

        y(t) = X(t) * beta_m +  Z(t) * state(t) + R(t) * eps(t); eps(t) ~ N(0, H(t)),
        for t = 1, 2, ..., nobs, and the state is generated by

        state(t + 1) = W(t) * beta_s + T(t) * state(t) + G(t)* eta(t); eta(t) ~ N(0, Q(t))
        for t=1, 2, ..., nobs - 1.

        state(1) ~ N(a1, P1)

        Note in the code we pass in beta = (beta_s^{T}, beta_m^{T})^{T}.
        That is we simply concatenate beta_s and beta_m to form beta.

    arguments:
        nobs - An integer specifing the number of time series observations.

        nseries - An integer specifing the number of time series.

        nstate - An integer specifying the dimension of the state vector.

        rstate - An integer specifying the dimension of Q(t).

        nreg - Is the number of regressors in the measurement equation.

        sreg - Is the number of regressors in the state equation.

        timevar - A single boolean or a dictionary of keywords and
                  booleans.  Boolean Case: True => everything is
                  time-varying, otherwise everything not time varying
                  Dictionary: {'name': True } => name is time varying.


        unifilter - A boolean that is True is H(t) is diagonal and False otherwise.

    optional arguments:
        joint_sample: Sample the regressors and the state jointly, using the algorithm of
                      de Jong and Shephard(1995).

    public member functions:
        update_zt(zt) - Updates the class for Z(t).

        update_ht(ht) - Updates the class for H(t).

        update_tt(tt) - Updates the class for T(t).

        update_qt(qt) - Updates the class for Q(t).

        update_gt(gt) - Updates the class for G(t).

        update_gt_qt(gt, qt, **kwargs) - Updates the class for both G(t) and
                                       Q(t).

        update_beta(beta) - Updates the class for beta.

        update_xmat(xmat) - Updates the class for xmat.

        update_wmat(wmat) - Updates the class for wmat.


    """
#   --------------------------------------------------------------------

    def __init__(self, nobs, nseries, nstate, rstate, nreg, sreg, timevar, noname_flag,
                 tproperties, missingv, **kwargs):

        System.__init__(self, nobs, nseries, nstate, rstate, timevar,
                        noname_flag, tproperties, missingv)
        self.nreg = nreg
        self.sreg = sreg
        self.jointly_sample = False
        self.__beta = np.zeros(self.nreg + self.sreg)

        if 'joint_sample' in kwargs:

            self.__W0 = None  # placemat
            assert self.sreg > 0
            #Note W0.shape[1] and self.sreg should always be > 0
            #when using the 'joint sample' option
            #W0 should be a (self.nstate, self.sreg) matrix
            prior = kwargs['joint_sample']  # Shortcut to priors
            if prior[0] == 'diffuse':

                #Check in the diffuse case to see if prior contains only 2 arguments
                try:
                    assert len(prior) == 2
                except:
                    error = "In the diffuse case joint_sample = ['diffuse', W0], only"
                    raise Exception(error)

                self.__b = np.zeros(self.sreg + self.nreg)
                #b.shape[0] and B.shape[0] should equal self.sreg + self.nreg
                self.__B = np.eye(self.sreg + self.nreg)
                # Concaternate B and b, i.e. Bb = [B|b]
                self.__Bb = np.hstack([self.__B, self.__b.reshape(self.__b.shape[0], 1)])
                self.update_W0(prior[1])
                self.ind_diffuse = True

            else:
                #Check prior contains 3 arguments
                try:
                    assert len(prior) == 3
                except:
                    error = "joint_sample should = [b, B, W0]."
                    raise Exception(error)

                self.__b = np.atleast_1d(prior[0])
                #b.shape[0] and B.shape[0] should equal self.sreg + self.nreg
                self.__B = np.atleast_2d(prior[1])
                # Concaternate B and b, i.e. Bb = [B|b]
                self.__Bb = np.hstack([self.__B, self.__b.reshape(self.__b.shape[0], 1)])
                self.update_W0(prior[2])
                self.ind_diffuse = False

            self.joint_sample = True  # Set flag

        # -----------------------------------------------
        if self.joint_sample is False:
            if self.nreg > 0:
                self.__xbeta = np.zeros((nseries, nobs), order='F')
                self.__xmat = np.zeros((nseries, nreg, nobs), order='F')
            if self.sreg > 0:
                self.__wmat = np.zeros((nstate, sreg, nobs), order='F')
                self.__wbeta = np.zeros((nstate, nobs), order='F')

        else:
            self.__xmat = np.zeros((nseries, nreg, nobs), order='F')
            self.__wmat = np.zeros((nstate, sreg, nobs), order='F')

            if self.nreg > 0:
                self.__xbeta = np.zeros((nseries, nobs), order='F')
                self.__xbb = np.zeros((nseries, nreg + sreg + 1, nobs), order='F')
            else:
                # dummy argument required for diffuse kalman filter
                self.__xbb = np.zeros((nseries, 0, nobs), order='F')

            if self.sreg > 0:
                self.__wbeta = np.zeros((nstate, nobs), order='F')
                self.__wbb = np.zeros((nstate, nreg + sreg + 1, nobs), order='F')
            else:
                # dummy argument required for diffuse kalman filter
                self.__wbb = np.zeros((nstate, 0, nobs), order='F')

#   --------------------------------------------------------------------

    def update_bB(self, b, B):
        """Function updates prior hyperparameters b and B."""

        #ensure dimensions of parameters are correct
        try:
            assert b.shape[0] == B.shape[0] == B.shape[1] == self.__b.shape[0]
        except:
            raise ValueError("The dimensions of b and\or B in updatebB are incorrect.")

        self.__b = np.atleast_1d(b)
        self.__B = np.asfortranarray(np.atleast_2d(B))
        self.__Bb = np.asfortranarray(np.hstack([self.__B,
                                                 self.__b.reshape(self.__b.shape[0], 1)]))
        if self.nreg > 0:
            filterreg.update_xbb(self.xbb(), self.__xmat, self.Bb())
        self.__A1 = np.dot(self.__W0, self.__Bb)
        if self.sreg > 0:
            filterreg.update_wbb(self.__wbb, self.__wmat, self.Bb())

#   --------------------------------------------------------------------

    def update_beta(self, beta):
        """Function updates the value of beta stored in the class"""

        beta = np.atleast_1d(beta)
        try:
            assert (beta.shape[0] == (self.sreg + self.nreg))
        except:
            error = """The dimension of beta should = the number of regressors
            in the measurement equation + the number of regressors in the state
            equation. The dimension of beta is not conformable."""

            raise Exception(error)

        self.__beta = beta

        if self.sreg > 0:
            filterreg.update_xwbeta(self.__wmat, self.__beta[:self.sreg],
                            self.__wbeta)

        if self.nreg > 0:
            filterreg.update_xwbeta(self.__xmat, self.__beta[self.sreg:],
                                    self.xbeta())

#   --------------------------------------------------------------------

    def update_xmat(self, xmat):
        """Function updates the value of xmat that has been stored"""

        xmat = np.atleast_3d(xmat)
        assert xmat.shape[0] == self.nseries
        assert xmat.shape[1] == self.nreg
        if xmat.shape[2] == 1:
            xmat = np.tile(xmat, (1, self.nobs))
        assert xmat.shape[2] == self.nobs

        self.__xmat = np.asfortranarray(xmat)
        if self.joint_sample:
            filterreg.update_xbb(self.xbb(), self.__xmat, self.Bb())

        filterreg.update_xwbeta(self.__xmat, self.__beta[self.sreg:],
                                self.xbeta())

#   --------------------------------------------------------------------

    def update_W0(self, W0):
        """Function updates the value of W0 that has been stored"""
        W0 = np.atleast_2d(W0)
        assert W0.shape[0] == self.nstate
        assert W0.shape[1] == self.sreg
        if self.nreg > 0:
            #concatenates zeros to the end to account for regressors in
            #the measurement equation
            W0 = np.hstack([W0, np.zeros((self.nstate, self.nreg))])

        self.__W0 = np.asfortranarray(W0)
        self.__A1 = np.dot(self.__W0, self.__Bb)

    def update_wmat(self, wmat):
        """Function updates the value of wmat that has been stored"""

        wmat = np.atleast_3d(wmat)
        assert wmat.shape[0] == self.nstate
        assert wmat.shape[1] == self.sreg
        if wmat.shape[2] == 1:
            wmat = np.tile(wmat, (1, self.nobs))
        assert wmat.shape[2] == self.nobs

        self.__wmat = np.asfortranarray(wmat)
        if self.joint_sample:
        # Compute: wbb(t) = W(t) * Bb
            filterreg.update_wbb(self.__wbb, self.__wmat, self.Bb())

        filterreg.update_xwbeta(self.__wmat, self.__beta[:self.sreg],
                        self.__wbeta)
#   --------------------------------------------------------------------
#   Access Functions:

    def xmat(self):
        """Function returs the current value for xmat"""

        return self.__xmat

    def wmat(self):
        """Function returns the current value for wmat"""

        return self.__wmat

    def beta(self):
        """Function returns the current value for beta"""

        return self.__beta

    def b(self):
        """Function returns the current value for b"""

        return self.__b

    def B(self):
        """Function returns the current value for B"""

        return self.__B

    def Bb(self):
        """Function returns the current value for Bb"""

        return self.__Bb

    def wbeta(self):
        """Function returns the current value for wbeta"""

        return self.__wbeta

    def xbeta(self):
        """Function returns the current value for xbeta"""

        return self.__xbeta

    def A1(self):
        """Function returns the current value for A1"""

        return self.__A1

    def wbb(self):
        """Function returns the current value for wbb"""

        return self.__wbb

    def xbb(self):
        """Function returns the current value for xbb"""

        return self.__xbb

    def W0(self):
        """Function returns the current value for W0"""

        return self.__W0


#-----------------------------------------------------------------------

class Filter(FilterBase):
    """Class provides filtering and classical smoothing algorithms for the SSM with
    regressors, where the SSM is specified following:

        y(t) = X(t) * beta_m +  Z(t) * state(t) + R(t) * eps(t); eps(t) ~ N(0, H(t)),
        for t = 1, 2, ..., nobs, and the state is generated by

       state(t + 1) = W(t) * beta_s + T(t) * state(t) + G(t) * eta(t); eta(t) ~ N(0, Q(t))
        for t=1, 2, ..., nobs - 1.

        state(1) ~ N(a1, P1)

        Note in the code we pass in beta = (beta_s^{T}, beta_m^{T})^{T}.
        That is we simply concatenate beta_s and beta_m to form beta.

    arguments:

        nobs - An integer specifing the number of time series observations.

        nseries - An integer specifing the number of time series.

        nstate - An integer specifying the dimension of the state vector.

        rstate - An integer specifying the dimension ot Q(t).

        timevar - A single boolean or a dictionary of keywords and
                  booleans.  Boolean Case: True => everything is
                  time-varying, otherwise everything not time varying
                  Dictionary: {'name': 'True" } => name is time
                  varying.

    optional arguments(**kwargs):
        joint_sample - Use the augmented kalman filter proposed by de Jong (1991).

        filter - specfies what filtering algorithm to use. There are two options.
                 Namely 'dkbenchmark', 'c_filter'. If no options are specfied then
                 the default filtering algorithm is used. Note that 'dkbenchmark'
                 refers to a filter that is implemented following Durbin and Koopman
                 (2001), without any alteration. This algorithm can be very inefficient and
                 only should be used for benchmarking. The algorithm 'c_filter' is the
                 contemporaneous version of the Kalman filter.

        smoother - By default the state smoother is used, however there is the option of
                   using a disturbance smoother. Thie is used simply through the option
                   'disturbance'.


        properties - Allows for certain optimisations. The input should be a dictionary
                     specifing structure in certain matrices that allow for certain
                     optimisations. Allowable options are listed below with the keyword
                     on the left and the property on the right. Note that the optimisations
                     will only effect certain algorithms, so there is no guarantee of any
                     performance gain. It is unlikely to lead to any performance loss
                     however so if known this information should be included.

                     'ht': 'diag'
                         Note this option can be used if H(t) is a diagonal matrix. In
                         this case only the diagonal for H(t).

                     'gt': 'eye'
                         Note this option can be used when G(t) is an identity matrix.

                     'tt': 'eye'
                         Note that this option can be used when T(t) is an identity matrix.


    """
#   --------------------------------------------------------------------

    def __init__(self, nobs, nseries, nstate, rstate, timevar, **kwargs):
        FilterBase.__init__(self, nobs, nseries, nstate, rstate, timevar, **kwargs)

        #default initialisation
        self.nreg, self.sreg = 0, 0

        if 'xmat' in kwargs:
            xmat = np.atleast_1d(kwargs['xmat'])
            if xmat.ndim > 1:
                self.nreg = xmat.shape[1]
            else:
                self.nreg = 1
                assert kwargs['xmat'] == 1.

        if 'wmat' in kwargs:
            wmat = np.atleast_1d(kwargs['wmat'])
            if wmat.ndim > 1:
                self.sreg = wmat.shape[1]
            else:
                self.sreg = 1

        self.kreg = self.nreg + self.sreg + 1

        #Note flag_nmissing -
        #   None - No missing data
        #   1 - Missing data only over entire columns of ymat
        #   2 - Missing data over partial column of ymat

        #Note missing in kwargs required to tell if ymat is going to inclued
        #missing data
        if 'missing' in kwargs and kwargs['missing'] is True:
            flag_missing = True
        else:
            flag_missing = False

        #if regressors in SSM overide base class
        if self.sreg + self.nreg > 0:
            assert 'wmat' in kwargs or 'xmat' in kwargs

            if 'properties' in kwargs.keys():
                assert type(kwargs['properties']) == type({})
                properties = kwargs['properties']
            else:
                properties = {}

            self.sys = SystemReg(nobs, nseries, nstate, rstate,
                                 self.nreg, self.sreg, timevar,
                                 self.noname_flag, properties,
                                 flag_missing, **kwargs)
            if self.sys.flag_some_tv is True:
                self._gen_state = self.__gen_state_reg_tv

            else:
                self._gen_state = self.__gen_state_reg_ntv

            if self.sys.flag_some_tv is True:
                self._gen_state = self.__gen_state_reg_tv

            else:
                self._gen_state = self.__gen_state_reg_ntv

        self.flag_some_tv = self.sys.flag_some_tv

        if 'wmat' in kwargs:
            self.sys.update_wmat(kwargs['wmat'])

        if 'xmat' in kwargs:
            self.sys.update_xmat(kwargs['xmat'])

        if 'joint_sample' in kwargs:
            self.joint_sample = True
            self.ttat = np.zeros((nstate, self.kreg), order='F')
            self.qmat = np.zeros((self.kreg, self.kreg), order='F')
            self.work_nu = np.zeros((nseries, self.kreg), order='F')

            self.Nustore = np.zeros((nseries, self.kreg, self.nobs), order='F')
            self.Smat = np.zeros((self.kreg, self.kreg))
            self.svec = np.zeros(self.kreg)
            self.cholS = np.zeros((self.kreg, self.kreg))

        else:
            self.joint_sample = False

        if self.sreg + self.nreg > 0:
            self.__log_likelihood = self.__calc_loglikelihood_reg

        else:
            self.__log_likelihood = self._log_likelihood

        if self.flag_some_tv is True:
            if self.joint_sample is False:
                if self.sreg + self.nreg > 0:
                    if self.unifilter is False:
                        self._filter = self.__filter_reg_tv
                        self._simulate_ssm = self.__simulate_ssm_reg_tv
                    else:
                        self._filter = self.__filter_reg_tv
                        self._simulate_ssm = self.__simulate_ssm_reg_tv_uni

            else:
                self._filter = self.__filter_reg_joint_tv
                #self.log_likelihood = self.__calc_loglikelihood_joint_sample

                # note only calculate likelihood for the case when either sreg
                # or nreg == 0. This is for identification purposes
                #if self.sreg > 0:
                #    self.log_likelihood = self.__calc_loglikelihood_state_reg
                #if self.nreg > 0:
                #    self.log_likelihood = self.__calc_loglikelihood_meas_reg
                #if self.sreg > 0 and self.nreg > 0:
                #    self.log_likelihood = self.__calc_loglikelihood_measstate_reg

        else:
            if self.sreg + self.nreg > 0:
                if self.unifilter is False:
                    self._filter = self.__filter_reg_ntv
                    self._simulate_ssm = self.__simulate_ssm_reg_ntv
                else:
                    # need to correct for filter
                    self._filter = self.__filter_reg_ntv
                    self._simulate_ssm = self.__simulate_ssm_reg_ntv_uni

            if self.joint_sample is True:
                self._filter = self.__filter_reg_joint_ntv
                #self.log_likelihood = self.__calc_loglikelihood_joint_sample

        if self.joint_sample is False:
            if self.nreg > 0:
                self.ystar = np.zeros((nseries, nobs), order='F')
            else:
                self.ystar = None

#   --------------------------------------------------------------------

    def initialise_system(self, a1, p1, zt, ht, tt, gt, qt, rt, **kwargs):
        """Function initialises system matrices."""

        self.sys.update_zt(zt)
        self.sys.update_rt_ht(rt, ht)
        self.sys.update_tt(tt)

        self.sys.update_gt_qt(gt, qt)
        self.sys.update_a1(a1)
        self.sys.update_p1(p1)

        if 'beta' in kwargs:
            self.sys.update_beta(kwargs['beta'])
        else:
            if self.nreg + self.sreg > 0:
                self.sys.update_beta(np.zeros(self.sreg + self.nreg))
        self.init_sys = True

#   --------------------------------------------------------------------

    def update_beta(self, beta):
        """Function updates the value of the vector beta."""

        beta = np.atleast_1d(beta)
        assert(beta.shape[0] == self.nreg + self.sreg)
        self.sys.update_beta(beta)

#   --------------------------------------------------------------------

    def update_wmat(self, wmat):
        """Function updates the value of the (nstate, sreg, nobs) array that
        is used to store regressors in the state."""

        assert self.sreg > 0
        self.sys.update_wmat(wmat)

#   --------------------------------------------------------------------

    def update_xmat(self, xmat):
        """Function updates the value of the (nseries, nreg, nobs) array that
        is used to store regressors in the measurement equation."""

        assert self.nreg > 0
        self.sys.update_xmat(xmat)

#   --------------------------------------------------------------------

    def log_likelihood(self):
        """Overide member function in base class"""
        return self.__log_likelihood()

    #def __calc_loglikelihood_joint_sample(self):
    #    """Helper function for calculating the log likelihood for the
    #    augmented Kalman filter of de Jong (1991)."""

    #
    #    self.ilike = 0
    #    self._filter()
    #    self.ilike = 1
    #    const =  -0.5 * self.nobs * self.nseries * np.log(2.0 * np.pi)
    #    system = self.get_system()
    #
    #    #k = self.nreg + self.sreg
    #   #
    #    #self.Smat = self.qmat[:k, :k]
    #    #self.svec = -self.qmat[:k, -1]
    #    q = self.qmat[-1,-1]
    #    #tnobs = self.nseries * self.nobs

    #    #if all(self.svec == 0):
    #    #    ssq = q
    #    #else:
    #    #    ssq = (q - np.dot(self.svec,
    #    #                    np.linalg.solve(self.Smat, self.svec)))
    #    ##if system.ind_diffuse is True:
    #    ##    temp2 = -0.5 * ssq
    #    ##else:
    #    #sigsqhat = ssq / tnobs
    #    ##temp2 = -0.5 * (tnobs *  np.log(sigsqhat))
    #    #temp2 = -0.5 * ssq
    #    temp2 = -0.5 * q
    #
    #
    #
    #    #if system.ind_diffuse is True:
    #    #    temp2 = temp2 - np.sum(np.log(np.diag(np.linalg.cholesky(self.Smat))))
    #
    #    return temp2 + const + self.loglike

#   --------------------------------------------------------------------
    def __calc_loglikelihood_reg(self):
        """function overides log_likelihood function in FilterBase class;
        for the case where there are regressors in the SSM."""

        self.ilike = 0
        if self.flag_some_tv:
            self.__filter_reg_tv()
        else:
            self.__filter_reg_ntv()
        self.ilike = 1

        temp = self.nseries * self.nobs * np.log(2.0 * np.pi) * 0.5
        #pdb.set_trace()

        return self.loglike - temp

    def __filter_reg_joint_ntv(self):
        """Helper function for the augmented simulation of de Jong when none of the
        system matrices are time varying."""

        self.qmat[:, :] = 0.0
        at = self.sys.A1().copy()
        pt = np.asfortranarray(self.sys.p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr

        filterreg.srdntfilter(self.ymat, self.sys._zt(), ht,
                              self.sys._tt(), self.sys._gqg(),
                              self.Nustore, self.kstore, self.ft,
                              self.sstore, at,  pt, self.mt,
                              self.work, self.lstore, self.info,
                              self.sys.wbb(), self.sys.xbb(), self.ttat,
                              self.qmat, self.work_nu,
                              self.loglike, self.ilike)

#   --------------------------------------------------------------------

    def __filter_reg_joint_tv(self):
        """Helper function for the augmented simulation of de Jong when at least
        one of the system matrices are time varying."""

        self.qmat[:, :] = 0.0
        at = np.asfortranarray(self.sys.A1().copy())
        pt = np.asfortranarray(self.sys.p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr

        filterreg.srdfilter(self.ymat, self.sys._zt(), ht,
                            self.sys._tt(), self.sys._gqg(),
                            self.Nustore, self.kstore, self.ft,
                            self.sstore, at, pt, self.mt,
                            self.work, self.lstore, self.info,
                            self.sys.wbb(), self.sys.xbb(), self.ttat,
                            self.qmat, self.work_nu,
                            self.loglike, self.ilike)

#   --------------------------------------------------------------------

    def __filter_reg_tv(self):
        """Helper function to calculate the loglikelihood when there
        are regressors in the SSM and at least one of the system matricies
        are time varying."""

        if self.nreg > 0:
            #there are regressors in the measurement equation
            self.ystar = np.asfortranarray(self.ymat - self.sys.xbeta())
        else:
            self.ystar = self.ymat

        at = self.sys.a1().copy()
        pt = np.asfortranarray(self.sys.p1().copy())
        self.loglike = np.array(0.0)
        ht = self.sys._rhr()  # Replace ht with rhr

        if self.sreg == 0:
            #there are no regressors in the state equation

            if self.unifilter:

                uni.unifilter(self.ystar, self.nustore_fstore,
                              self.kstore, self.astore, self.pstore,
                              at, pt, self.sys._zt(), ht, self.mt,
                              self.sys._tt(), self.sys._gqg(),
                              self.pttt, self.loglike, self.properties_tt,
                              self.ilike)
            else:
                stdfilter.filter(self.ystar, self.sys._zt(), ht,
                                 self.sys._tt(), self.sys._gqg(),
                                 self.nustore, self.kstore, self.ft,
                                 self.sstore, self.astore, at,
                                 pt, self.pstore, self.mt, self.work,
                                 self.lstore, self.loglike, self.work_like,
                                 self.info, self.properties_tt, self.ilike,
                                 self.partial_missing)
        else:
            #there are regressors in the state equation

            if self.unifilter:
                uni.unifilter_r(self.ystar, self.nustore_fstore, self.kstore,
                                self.astore, self.pstore, at, pt, self.sys._zt(),
                                ht, self.mt, self.sys._tt(), self.sys._gqg(),
                                self.pttt, self.loglike, self.properties_tt,
                                self.ilike, self.sys.wbeta())
            else:

                filterreg.srfilter(self.ystar, self.sys._zt(), ht,
                 self.sys._tt(), self.sys._gqg(), self.nustore,
                 self.kstore, self.ft, self.sstore, self.astore, at,
                 pt, self.pstore, self.mt, self.work, self.lstore,
                 self.loglike, self.ilike, self.info,
                 self.sys.wbeta(), self.partial_missing, self.work_like)
                

                assert self.info == 0

    def __filter_reg_ntv(self):
        """Helper function to calculate the loglikelihood when there
        are regressors in the SSM and none of the system matricies
        are time varying."""

        #Ensures there are no missing data as it is not compatible
        #with this specification.
        try:
            assert self.flag_missing is None
        except:
            error = """You need to tell the class Filter that missing = True
            on initialisation if you have missing data."""

            raise Exception(error)

        if self.nreg > 0:
            #there are regressors in the measurement equation
            filterreg.calcxbeta(self.sys.xmat(),
                                self.sys.beta()[self.sreg:], self.sys.xbeta())
            self.ystar = np.asfortranarray(self.ymat - self.sys.xbeta())
        else:
            self.ystar = self.ymat

        self.loglike = np.array(0.)
        at = self.sys.a1().copy()
        pt = np.asfortranarray(self.sys.p1().copy())
        ht = self.sys._rhr()  # Replace ht with rhr
        self.last_t = self.nobs + 1

        if self.sreg == 0:
            #there are no regressors in the state equation
            if self.unifilter:

                uni.ntunifilter(self.ystar, self.nustore_fstore,
                                self.kstore, self.astore, self.pstore,
                                at, pt, self.sys._zt(), ht, self.mt,
                                self.sys._tt(), self.sys._gqg(),
                                self.pttt, self.last_t, self.loglike, self.ilike)
            else:
                stdfilter.ntfilter(self.ystar, self.sys._zt(), ht,
                                   self.sys._tt(), self.sys._gqg(),
                                   self.nustore, self.kstore, self.ft,
                                   self.sstore, self.astore, at,
                                   pt, self.pstore, self.mt, self.work,
                                   self.lstore, self.last_t, self.loglike,
                                   self.work_like, self.info, self.ilike)
        else:
            #there are regressors in the state equation

            if self.unifilter:
                uni.ntunifilter_r(self.ystar, self.nustore_fstore,
                        self.kstore, self.astore, self.pstore,
                        at, pt, self.sys._zt(), ht, self.mt,
                        self.sys._tt(), self.sys._gqg(), self.pttt,
                        self.loglike, self.ilike,
                        self.sys.wbeta())
            else:
                filterreg.ntsrfilter(self.ystar, self.sys._zt(), ht,
                     self.sys._tt(), self.sys._gqg(),
                     self.nustore, self.kstore, self.ft,
                     self.sstore, self.astore, at,
                     pt, self.pstore, self.mt, self.work,
                     self.lstore, self.loglike, self.ilike,
                     self.info, self.sys.wbeta(), self.work_like)

                assert(self.info == 0)

#   --------------------------------------------------------------------

    def __simulate_ssm_reg_tv_uni(self):
        """Helper function to simulation from a state space model with regressors
        when both R(t) and H(t) are diagonal, and at least one of
        the system matrices is time varying."""

        cht = self.sys._rcht()  # Replace cht with rcht
        if self.sreg == 0:
            #there are no regressors in the state equation

            uni.simssm(self.ymat, self.sys._zt(), cht, self.sys.tt(),
                self.sys._gcqt(),  self.rand_meas,
                self.rand_state, self.state)
        else:
            uni.srsimssm(self.ymat, self.sys._zt(), cht, self.sys.wbeta(),
                self.sys._tt(), self.sys._gcqt(),
                self.rand_meas, self.rand_state, self.state)

        if self.nreg > 0:
            #there are regressors in the measurement equation
            filterreg.calcxbeta(self.sys.xmat(),
                                self.sys.beta()[self.sreg:], self.sys.xbeta())
            self.ymat = self.ymat + self.sys.xbeta()

    def __simulate_ssm_reg_ntv_uni(self):
        """Helper function to simulation from a state space model with regressors
        when both R(t) and H(t) are diagonal, and none of
        the system matrices is time varying."""

        cht = self.sys._rcht()  # Replace cht with rcht
        if self.sreg == 0:
            #there are no regressors in the state equation
            uni.ntsimssm(self.ymat, self.sys._zt(), cht,
                self.sys.tt(), self.sys._gcqt(), self.rand_meas,
                self.rand_state, self.state)

        else:
            uni.ntsrsimssm(self.ymat, self.sys._zt(), cht,
                           self.sys.wbeta(), self.sys._tt(),
                           self.sys._gcqt(), self.rand_meas,
                           self.rand_state, self.state)

        if self.nreg > 0:
            #there are regressors in the measurement equation
            filterreg.calcxbeta(self.sys.xmat(),
                                self.sys.beta()[self.sreg:], self.sys.xbeta())
            self.ymat = self.ymat + self.sys.xbeta()

#   --------------------------------------------------------------------

    def __simulate_ssm_reg_tv(self):
        """Helper function to simulate from the state space model
        when there are regressors and at least one of the system matrices is time
        varying."""

        cht = self.sys._rcht()  # Replace cht with rcht

        if self.sreg > 0:
            filterreg.srsimssm(self.ymat, self.sys._zt(), cht, self.sys._tt(),
                self.sys._gcqt(), self.rand_meas, self.rand_state,
                self.state, self.sys.wbeta())
        else:
            if self.sim_d_flag is True:
                gcqt = self.sys._gt()
            else:
                gcqt = self.sys._gcqt()
            stdfilter.calc_st_er(gcqt, self.sys._cqt(), self.rand_state,
                                 self.state_error,
                                 self.sim_d_flag)
            cht = self.sys._rcht()  # Replace cht with rcht

            stdfilter.simssm(self.ymat, self.sys._zt(), cht,
                             self.sys._tt(), self.state_error,
                             self.rand_meas, self.state)
        if self.nreg > 0:
            #there are regressors in the measurement equation
            filterreg.calcxbeta(self.sys.xmat(),
                                self.sys.beta()[self.sreg:], self.sys.xbeta())
            self.ymat = self.ymat + self.sys.xbeta()

    def __simulate_ssm_reg_ntv(self):
        """Helper function to simulate from the state space model
        when there are regressors and none of the system matrices are time
        varying."""

        if self.sreg > 0:
            cht = self.sys._rcht()  # Replace cht with rcht

            filterreg.ntsrsimssm(self.ymat, self.sys._zt(), cht,
                                 self.sys._tt(), self.sys._gcqt(),
                                 self.rand_meas, self.rand_state,
                                 self.state, self.sys.wbeta())
        else:
            if self.sim_d_flag is True:
                gcqt = self.sys._gt()
            else:
                gcqt = self.sys._gcqt()
            stdfilter.nt_calc_st_er(gcqt, self.sys._cqt(),
                                    self.rand_state, self.state_error,
                                    self.sim_d_flag)
            cht = self.sys._rcht()  # Replace cht with rcht
            stdfilter.ntsimssm(self.ymat, self.sys._zt(), cht,
                               self.sys._tt(), self.state_error,
                               self.rand_meas, self.state)

        if self.nreg > 0:
            #there are regressors in the measurement equation
            filterreg.calcxbeta(self.sys.xmat(),
                                self.sys.beta()[self.sreg:], self.sys.xbeta())
            self.ymat = self.ymat + self.sys.xbeta()

# ----------------------------------------------------------------------
    def __gen_state_reg_tv(self):
        """Helper function to generate the state from the residuals
        when there are regressors in the state equation and at least one
        of the regressors is time varying."""

        system = self.get_system()
        self.ahat[:, 0] = system.a1() + np.dot(system.p1(), self.rvec)
        filterreg.rgenstate(self.ehat, system._tt(), system._gt(),
                            self.ahat, system.wbeta())

#   --------------------------------------------------------------------

    def __gen_state_reg_ntv(self):
        """Helper function to generate the state from the residuals
        when there are regressors in the state equation and none
        of the regressors is time varying."""
        system = self.get_system()
        self.ahat[:, 0] = system.a1() + np.dot(system.p1(), self.rvec)
        filterreg.ntrgenstate(self.ehat, system._tt(), system._gt(),
                              self.ahat, system.wbeta())


# ----------------------------------------------------------------------

class SimSmoother(SimSmootherBase):
    """Class for simulation smoothing for the SSM with regressors. It is assumed
    the SSM is generated according to,

        y(t) = X(t) * beta_m +  Z(t) * alpha(t) + R(t) * eps(t); eps(t) ~ N(0, H(t)),
        for t = 1, 2, ..., nobs, and the state is generated by

        alpha(t + 1) = W(t) * beta_s + T(t) * alpha(t) + G(t) * eta(t); eta(t) ~ N(0, Q(t))
        for t=1, 2, ..., nobs - 1.

        Note in the code we pass in beta = (beta_s^{T}, beta_m^{T})^{T}.
        That is we simply concatenate beta_s and beta_m to form beta.

    arguments:
        ymat - Is an (nseries, nobs) matrix of observations.

        nstate - Is an integer specifying the dimension of the state vector.

        rstate - Is an integer specifying the dimension of Q(t).

        nreg - Is an integer specifying the number of regressors in the measurement
               equation.

        sreg - Is an integer specifying the number of regressors in the state
               equation.

        timevar - A single boolean or a dictionary of keywords and
                  booleans.  Boolean Case: True => everything is
                  time-varying, otherwise everything not time varying
                  Dictionary: {'name': 'True" } => name is time
                  varying.

    optional arguments(**kwargs):
        DO NOT USE THIS OPTION; IT IS FOR TESTING ONLY; NOT ALL OF THE ALGORITHMS
        WORK CORRECTLY!!!

        simulation_smoother - dejong_shephard
                              Use the simulation smoother of deJong and Shephard (1995)

                            - FSCK
                              Use the simulation smoother of Fruwirth Schnatter (1994)
                              and Carter and Kohn(1994).

                            - dkbenchmark
                            Use the simulation smoother of Durbin and Koopman (2002) as
                            written in the paper with out modification. Should only be
                            used for benchmarking is innefficient for some cases.

                            If none of these options are given then the default
                            simulation smoother is a re-arranged version of Durbin and
                            Koopman (2002) or the simulation smoother of Strickland,
                            Turner, Denham and Mengersen (2008).
                            Note that apart from dkbenchmark, which is
                            programmed precicely following the algorithms presented in
                            their paper all the other algorithms have been re-arranged
                            for an efficient implementation. The main in-efficiency
                            arrises with their formulation in the case that nseries is
                            large.

        joint_sample - Use the augmented simulation smoother of de Jong and Shephard(1995)
                       to jointly sample the regressors and the state. This option
                       overides the option for simulation_smoother

    """
#   --------------------------------------------------------------------

    def __init__(self, ymat, nstate, rstate, timevar, **kwargs):

        if 'joint_sample' in kwargs:
            kwargs['simulation_smoother'] = 'dejong_shephard'
        SimSmootherBase.__init__(self, ymat, nstate, rstate, timevar, **kwargs)

        nseries, nobs = np.atleast_2d(ymat).shape

        #adjust for missing values
        if self.flag_missing:
            kwargs['missing'] = True

        if 'xmat' in kwargs or 'wmat' in kwargs or 'joint_sample' in kwargs:
            self.filter = Filter(nobs, nseries, nstate, rstate, timevar, **kwargs)

            system = self.get_system()
            self.nreg, self.sreg = system.nreg, system.sreg

            if 'joint_sample' in kwargs:
                self.filter.last_t = nobs + 1
                self.sim_smoother = self.__augmented_simulation_smoother

            if self.sreg > 0:
                if system.flag_some_tv is True:
                    self._calculate_state_error = self.__calculate_state_error_reg_tv
                    self._calculate_state_gerror = self.__calculate_state_gerror_reg_tv
                    self._gen_state = self.__gen_state_reg_tv

                else:
                    self._calculate_state_error = self.__calculate_state_error_reg_ntv
                    self._calculate_state_gerror = self.__calculate_state_gerror_reg_ntv
                    self._gen_state = self.__gen_state_reg_ntv

            if self.nreg > 0:
                if system.flag_some_tv is True:
                    self._calculate_meas_error = self.__calculate_meas_error_tv
                else:
                    self._calculate_meas_error = self.__calculate_meas_error_ntv

#   --------------------------------------------------------------------
    def update_xmat(self, xmat):
        """Function updates regressors (nseries, nreg, nobs) array that is in
        the measurement equation."""
        system = self.get_system()
        system.update_xmat(xmat)

#   --------------------------------------------------------------------

    def update_wmat(self, wmat):
        """Function updates the (nstate, sreg, nobs) array of regressors in the
        state equation.
        """
        system = self.get_system()
        system.update_wmat(wmat)

#   --------------------------------------------------------------------

    def initialise_system(self, a1, p1, zt, ht, tt, gt, qt, rt, **kwargs):
        """Function is used to initialise the system matricies.

        arguments:
            a1 - Is an vector of order nstate. It is the mean of the
                 initial state.

            p1 - Is an (nstate, nstate) matrix. It is the covariance
                 matrix for the initial state.

            zt - Is an (nseries, nstate) matrix in the case that Z(t)
                 does not change over time, otherwise it is an
                 (nseries, nstate, nobs) array.

            ht - Is an (nseries, nseries) matrix if H(t) does not
                 change over time and the property for H(t) was not
                 set to 'diag'. If the property (see properties option
                 for Filter above) was se to 'diag' then
                 ht is a vector of order nseries. For the case where
                 H(t) changes over time and the property for H(t) was
                 not set to 'diag' then ht is an (nseries, nseries, nobs)
                 array. In the case it the property option is set to 'diag'
                 then ht should be an (nseries, nobs) array.

            tt - Is an (nstate, nstate) matrix in the case T(t) does not
                 change         over time and is an (nstate, nstate, nobs) array
                 otherwise.

            gt - Is an (nstate, rstate) matrix in the case G(t) does not
                 change through time and is an (nstate, rstate, nobs) array
                 otherwise.

            qt - is an (rstate, rstate) matrix in the case Q(t) does not
                 change over time and is an (rstate, rstate, nobs) array
                 otherwise.

            beta - Is a (nreg + sreg) vector of regression coefficients.

        """

        self.filter.initialise_system(a1, p1, zt, ht, tt, gt, qt, rt, **kwargs)
        self.filter.update_ymat(self.ymat)

#   --------------------------------------------------------------------

    def __augmented_simulation_smoother(self):
        """Helper function for the augmented simulation smoother of de Jong and
        Shephard."""

        system = self.get_system()

        self.filter._filter()  # Call filter.  Note: Q matrix updated here

        k = self.nreg + self.sreg

        # S = first k rows and columns of Q
        # Compute: S = Q + I where I is k x k
        if system.ind_diffuse is False:
            self.Smat = self.filter.qmat[:k, :k] + np.eye(k)
        else:
            self.Smat = self.filter.qmat[:k, :k]

        # Compute: s = last column of Q, i.e. k th column
        self.svec = -self.filter.qmat[:k, -1]

        # Compute cholesky factorisation of S to get L where S = L.L'
        self.cholS = np.linalg.cholesky(self.Smat)

        # delta ~ N ( inv[S+I].s, sigma^2. inv[S+I])
        # Sample delta, i.e. delta = x + inv[L].z where x = inv[S+I].s
        # Solve (S+I). x = s,   i.e. Smat. x = svec
        # Solve L.x = z,  i.e. cholS.x = randomvalues
        deltamean = np.linalg.solve(self.Smat, self.svec)
        delta = deltamean + np.linalg.solve(self.cholS.T, np.random.randn(k))

        # Compute: beta = b + B.delta
        beta = system.b() + np.dot(system.B(), delta)

        system.update_beta(beta.copy())

        # Compute: a1 = W0 * beta
        a1 = np.dot(system.W0(), beta)
        system.update_a1(a1)
        # Compute: nu = Nu * svec
        temp = np.hstack([delta, 1.0])

        # Compute: nustore(:,t) = Nustore(:,:,t) * temp for all t=0,..,nobs-1
        filterreg.update_nustore(self.filter.nustore, self.filter.Nustore, temp)

        # Call dejong shepherd smoother

        self.filter.update_jt()
        system = self.filter.get_system()
        self.eta = np.asfortranarray(np.random.randn(system._qt().shape[0],
                                                     self.stateplus.shape[1]))

        self._dejong_shephard()

        #init_state = a1 + np.dot(system.gcqt(), random.randn(system._qt().shape[0]))
        #self.stateplus[:,0] = init_state
        self.stateplus[:, 0] = np.asfortranarray(a1 + np.dot(system._p1(),
                                                            self.filter.rvec)
            )

        self._gen_state()
        return self.stateplus

#   --------------------------------------------------------------------
    def __calculate_meas_error_tv(self, **kwargs):
        """Helper function calculates the measurment arrror in the case
        when at least one of the system matrices is time varying."""

        self.ystar = self.ymat - self.filter.sys.xbeta()

        if self.filter.sys.properties['rt'] == 'eye':
            rt_eye = True
        else:
            rt_eye = False

        if 'rteps' in kwargs and kwargs['rteps'] is True:
            rteps = 1  # compute R(t)*residual instead of residual
        else:
            rteps = 0

        uni.meas_res(self.ystar, self.filter.sys._zt(), self.stateplus,
            self.meas_residual, self.filter.sys._rt(), rt_eye, rteps)

    def __calculate_meas_error_ntv(self, **kwargs):
        """Helper function calculates the measurment arrror in the case
        when none of the system matrices is time varying."""

        self.ystar = self.ymat - self.filter.sys.xbeta()
        if self.filter.sys.properties['rt'] == 'eye':
            rt_eye = True
        else:
            rt_eye = False

        if 'rteps' in kwargs and kwargs['rteps'] is True:
            rteps = 1  # compute R(t)*residual instead of residual
        else:
            rteps = 0

        uni.ntmeas_res(self.ystar, self.filter.sys._zt(), self.stateplus,
            self.meas_residual, self.filter.sys._rt(), rt_eye, rteps)

    def __calculate_state_gerror_reg_tv(self, **kwargs):
        """Helper function to calculate G(t)*eta(t) when at
        least one of the system matrices is time varying."""

        system = self.get_system()
        if 'state_index' not in kwargs:
            filterreg.rstate_res(self.stateplus, system._tt(),
                                 self.state_Gresidual, system.wbeta())

        else:
            index = kwargs['state_index']
            filterreg.rstate_res(self.stateplus[index], system._tt()[index][:, index],
                                  self.state_Gresidual[index], system.wbeta()[index])

    def __calculate_state_error_reg_tv(self, **kwargs):
        """Helper function to calculate state residual when
        at least one of the system matrices is time varying."""

        self.__calculate_state_gerror_reg_tv(**kwargs)
        system = self.get_system()
        if 'state_index' not in kwargs:
            if system.properties['gt'] == 'eye':
                self.state_residual = self.state_Gresidual

            else:
                if system.timevar['gt'] is True:
                    gt = system._gt().copy()
                    uni.gres_res(self.state_Gresidual, gt,
                                 self.Gwork, self.Gsvec, self.info)
                    self.state_residual = self.state_Gresidual[: system._qt().shape[0], :]
                else:
                    self.state_residual = np.dot(np.linalg.pinv(system.gt()),
                                                self.state_Gresidual)
                assert self.info == 0
        else:
            index = kwargs['state_index']
            if system.properties['gt'] == 'eye':
                self.state_residual[index] = self.state_Gresidual[index, :]
            else:
                gt = system._gt()[index][:, index]
                uni.gres_res(self.state_Gresidual[index], gt,
                             self.Gwork, self.Gsvec, self.info)
                self.state_residual[index] = self.state_Gresidual[index]
                assert self.info == 0

#   --------------------------------------------------------------------

    def __calculate_state_gerror_reg_ntv(self, **kwargs):
        """Helper function to calculate G(t)*eta(t) when
        none of the system matrices is time varying."""

        system = self.get_system()
        if 'state_index' not in kwargs:
            filterreg.rntstate_res(self.stateplus, system._tt(),
                                   self.state_Gresidual, system.wbeta())
        else:
            index = kwargs['state_index']
            filterreg.rntstate_res(self.stateplus[index], system._tt()[index][:, index],
                                   self.state_Gresidual[index], system.wbeta()[index])

# ----------------------------------------------------------------------

    def __calculate_state_error_reg_ntv(self, **kwargs):
        """Helper function to calculate state residual when
        none of the system matrices is time varying."""

        self.__calculate_state_gerror_reg_ntv(**kwargs)
        system = self.get_system()
        if 'state_index' not in kwargs:
            properties = system.get_properties()
            if properties['gt'] == 'eye':
                self.state_residual = self.state_Gresidual
            else:
                self.state_residual = np.dot(np.linalg.pinv(system._gt()),
                                             self.state_Gresidual)
        else:
            index = kwargs['state_index']
            properties = system.get_properties()
            if properties['gt'] == 'eye':
                self.state_residual[index] = self.state_Gresidual[index]
            else:
                self.state_residual[index] = np.dot(
                    np.linalg.pinv(system._gt()[index][:, index]),
                    self.state_Gresidual[index])

#   --------------------------------------------------------------------

    def __gen_state_reg_tv(self):
        """Helper function to generate the state from the residuals when
        at least one of the system matrices is time varying."""

        system = self.filter.get_system()
        filterreg.rgenstate(self.eta, system._tt(), system._gt(),
                            self.stateplus, system.wbeta())

#   --------------------------------------------------------------------

    def __gen_state_reg_ntv(self):
        """Helper function to generate the state from the residuals when
        none of the system matrices is time varying."""

        system = self.filter.get_system()
        filterreg.ntrgenstate(self.eta, system._tt(), system._gt(),
                              self.stateplus, system.wbeta())
