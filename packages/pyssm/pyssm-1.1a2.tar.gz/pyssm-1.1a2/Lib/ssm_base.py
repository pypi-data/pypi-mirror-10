# Python base classes for State Space Models in the PySSM library
# Copyright (C) 2012  Chris Strickland

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 or version 3 of the
# License.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# --------------------------------------------------------------------
# Python code for state space models
# --------------------------------------------------------------------
import pdb
import unifilter as uni
import filter as stdfilter
import sys
import numpy as np
# --------------------------------------------------------------------
# Matrix Types:
# std = 0, eye = 1, diag = 2, inv = 3, chol = 4
# --------------------------------------------------------------------


class System:
    """
    Class store system matricies for the SSM. The SSM is assumed to be generated by:

        y(t) = Z(t) * state(t) + R(t) * epsilon(t); epsilon(t) ~ N(0, H(t)),
        for t = 1, 2, ..., nobs, and the state is generated by

        state(t+1) = T(t) * state(t) + G(t) * eta(t); eta(t) ~ N(0, Q(t)),
        for t=1, 2, ..., nobs - 1.

        The initial state is distributed such that state(1) ~ N(a1, p1).

    arguments:
        nobs - An integer specifing the number of time series observations.

        nseries - An integer specifing the number of time series.

        nstate - An integer specifying the dimension of the state vector.

        rstate - An integer specifying the dimension ot Q(t).

        timevar - A single boolean or a dictionary of keywords and booleans.
                  Boolean Case: True => everything is time-varying, otherwise everything not time varying
                  Dictionary: {'name': 'True" } => name is time varying.

        unifilter - A boolean that is True is H(t) is diagonal and False otherwise.
        missing - A boolean that is True if missing data is to be considered.

    public member functions:
        update_zt(zt) - Updates the class for Z(t).
        update_ht(ht) - Updates the class for H(t).
        update_tt(tt) - Updates the class for T(t).
        update_rt_ht(rt, ht) - Updates R(t) and H(t)
        update_qt(qt) - Updates the class for Q(t).
        update_gt(gt) - Updates the class for G(t).
        update_gt_qt(gt, qt) - Updates the class for both G(t) and
                                       Q(t).

    """

    def __init__(self, nobs, nseries, nstate, rstate, timevar, noname_flag,
                properties, missing):
        self.nobs = nobs
        self.nseries = nseries
        self.nstate = nstate
        self.rstate = rstate
        self.timevar = timevar
        self.nreg = 0
        self.sreg = 0
        self.noname_flag = noname_flag
        self.joint_sample = False  # Flag only required with regressors

        #storage for data
        self.ymat = np.zeros((nseries, nobs), order='F')
        #storeage for distibution parameters for initial state
        self.__a1 = np.zeros(nstate)
        self.__p1 = np.zeros((nstate, nstate), order='F')
        self.__cholp1 = np.zeros((nstate, nstate), order='F')
#       ----------------------------------------------------------------
        # Dictionary used for timevarying case

        self.timevar = {}    # Initialise empty dictionary

        # Initialise dictionary elements and default values
        self.timevar['zt'] = False
        self.timevar['ht'] = False
        self.timevar['tt'] = False
        self.timevar['qt'] = False
        self.timevar['gt'] = False
        self.timevar['rt'] = False


        if type(timevar) != type({}):        # Boolean parameter specified

            self.flag_some_tv = timevar      # Update flag

            if timevar is True:              # Set all values to True
                for key in self.timevar.keys():
                    self.timevar[key] = True

        elif type(timevar) == type({}):      # Dictionary specified

            self.timevar.update(timevar)     # Update dictionary
            self.flag_some_tv = False        # Default value
            if True in timevar.values():     # Look for a True element in the dictionary
                self.flag_some_tv = True     # Update flag

        #Note timevarying versions of the algorithms required for missing data
        if missing is True:
            self.flag_some_tv = True

        # --------------------------------------------------------

        # Dictionary used for certain optimisations
        self.properties = {}
        self.properties['zt'] = 'default'
        self.properties['ht'] = 'default'
        self.properties['tt'] = 'default'
        self.properties['gt'] = 'default'
        self.properties['qt'] = 'default'
        self.properties['rt'] = 'default'

        self.update_properties(properties)
#       ----------------------------------------------------------------
        # Storage required for the system matricies
#       ----------------------------------------------------------------
        # Allocate memory for Zt:
        if self.timevar['zt'] is True:
            self.__zt = np.zeros((nseries, nstate, nobs), order='F')
        elif self.flag_some_tv is True:
            self.__zt = np.zeros((nseries, nstate, 1), order='F')
        else:
            self.__zt = np.zeros((nseries, nstate), order='F')
#       ----------------------------------------------------------------
        # Allocate memory for Ht:
        ht_reduced = (self.properties['ht'] == 'diag' or self.properties['ht'] == 'eye')
        if(ht_reduced):
            size_of_dim_2 = 1
        else:
            size_of_dim_2 = nseries

        if self.timevar['ht'] is True:
            self.__ht = np.zeros((nseries, size_of_dim_2, nobs), order='F')
            self.__cht = np.zeros((nseries, size_of_dim_2, nobs), order='F')

        elif self.flag_some_tv is True:
            self.__ht = np.zeros((nseries, size_of_dim_2, 1), order='F')
            self.__cht = np.zeros((nseries, size_of_dim_2, 1), order='F')

        else:  # not time varying in any way:
            self.__ht = np.zeros((nseries, size_of_dim_2), order='F')
            self.__cht = np.zeros((nseries, size_of_dim_2), order='F')

#       ----------------------------------------------------------------
        # Allocate memory for Tt:
        if self.timevar['tt'] is True:
            self.__tt = np.zeros((nstate, nstate, nobs), order='F')
        elif self.flag_some_tv is True:
            self.__tt = np.zeros((nstate, nstate, 1), order='F')
        else:
            self.__tt = np.zeros((nstate, nstate), order='F')
#       ----------------------------------------------------------------
        # Allocate memory for Qt:
        if self.timevar['qt'] is True:
            self.__qt = np.zeros((rstate, rstate, nobs), order='F')
            self.__cqt = np.zeros((rstate, rstate, nobs), order='F')
        elif self.flag_some_tv is True:
            self.__qt = np.zeros((rstate, rstate, 1), order='F')
            self.__cqt = np.zeros((rstate, rstate, 1), order='F')
        else:
            self.__qt = np.zeros((rstate, rstate), order='F')
            self.__cqt = np.zeros((rstate, rstate), order='F')
#       ----------------------------------------------------------------
        # Allocate memory for Gt:
        if self.timevar['gt'] is True:
            self.__gt = np.zeros((nstate, rstate, nobs), order='F')
        elif self.flag_some_tv is True:
            self.__gt = np.zeros((nstate, rstate, 1), order='F')
        else:
            self.__gt = np.zeros((nstate, rstate), order='F')
#       ----------------------------------------------------------------
        # Allocate memory for products of Gt and Qt:
        if self.timevar['gt'] is True or self.timevar['qt'] is True:
            self.__gqg = np.zeros((nstate, nstate, nobs), order='F')
            self.__gcqt = np.zeros((nstate, rstate, nobs), order='F')
            self.__gqt = np.zeros((nstate, rstate), order='F')
        elif self.flag_some_tv is True:
            self.__gqg = np.zeros((nstate, nstate, 1), order='F')
            self.__gcqt = np.zeros((nstate, rstate, 1), order='F')
        else:
            self.__gqg = np.zeros((nstate, nstate), order='F')
            self.__gcqt = np.zeros((nstate, rstate), order='F')

#       ----------------------------------------------------------------
        # Allocate memory for Rt:
# WARNING: Rt diag cases requires 2nd dimension of size 1 for compatibility with other libraries - such as reducedc
        rt_reduced = (self.properties['rt'] == 'diag' or self.properties['rt'] == 'eye')
        if rt_reduced:
            size_of_dim_2 = 1
        else:
            size_of_dim_2 = nseries

        if self.timevar['rt'] is True:
            self.__rt = np.zeros((nseries, size_of_dim_2, nobs), order='F')

        elif self.flag_some_tv is True:
            self.__rt = np.zeros((nseries, size_of_dim_2, 1), order='F')

        else:    # not time varying in any way
            self.__rt = np.zeros((nseries, size_of_dim_2), order='F')

        # ---------------------------------------
        ht_reduced = (self.properties['ht'] == 'diag' or self.properties['ht'] == 'eye')
        if rt_reduced and ht_reduced:
            size_of_dim_2 = 1
        else:
            size_of_dim_2 = nseries
        

        if self.timevar['rt'] is True or self.timevar['ht'] is True:
            self.__rhr = np.zeros((nseries, size_of_dim_2, nobs), order='F')
            self.__rcht = np.zeros((nseries, size_of_dim_2, nobs), order='F')
            self.__rht = np.zeros((nseries, size_of_dim_2), order='F')
# WARNING: rht third dimension not required as it is a work np.array only - do not need to store for every time
        else:
            if rt_reduced and ht_reduced:
                if self.flag_some_tv is False:
                    self.__rhr = np.zeros(nseries)
                    self.__rcht = np.zeros(nseries)
                    self.__rht = np.zeros(nseries)
                else:
                    #extra dimension for compatibility with other libraries
                    self.__rhr = np.zeros((nseries, 1, 1), order='F')
                    self.__rcht = np.zeros((nseries, 1, 1), order='F')
                    self.__rht = np.zeros((nseries, 1, 1), order='F')
            else:
                if self.flag_some_tv is False:
                    self.__rhr = np.zeros((nseries, nseries), order='F')
                    self.__rcht = np.zeros((nseries, nseries), order='F')
                    self.__rht = np.zeros((nseries, nseries), order='F')
                else:
                    self.__rhr = np.zeros((nseries, nseries, 1), order='F')
                    self.__rcht = np.zeros((nseries, nseries, 1), order='F')
                    self.__rht = np.zeros((nseries, nseries, 1), order='F')

#   --------------------------------------------------------------------
#   Access Functions 1: These function return the member variable (as is)

    def _qt(self):
        return self.__qt

    def _gt(self):
        return self.__gt

    def _gqg(self):
        return self.__gqg

    def _gcqt(self):
        return self.__gcqt

    def _ht(self):
        return self.__ht

    def _cht(self):
        return self.__cht

    def _cqt(self):
        return self.__cqt

    def _zt(self):
        return self.__zt

    def _tt(self):
        return self.__tt

    def _a1(self):
        return self.__a1

    def _p1(self):
        return self.__p1

    def _cholp1(self):
        return self.__cholp1

    def _rt(self):
        return self.__rt

    def _rhr(self):
        return self.__rhr

    def _rcht(self):
        return self.__rcht

    def _rht(self):
        return self.__rht

#   --------------------------------------------------------------------
#   Access Functions 2: These function (typically) transform the member variable

    def a1(self):
        """returns value for a1"""
        return self.__a1

    def p1(self):
        """returns value for p1"""
        return self.__p1

    def qt(self):
        """returns value for qt"""
        if self.timevar['qt'] is False:
            if self.flag_some_tv is True:
                return self.__qt[:, :, 0]
        return self.__qt

    def gt(self):
        """returns value for gt"""
        if self.timevar['gt'] is False:
            if self.flag_some_tv is True:
                return self.__gt[:, :, 0]
        return self.__gt

    def zt(self):
        """returns value for zt"""
        if self.timevar['zt'] is False:
            if self.flag_some_tv is True:
                return self.__zt[:, :, 0]
        return self.__zt

    def tt(self):
        """returns value for tt"""
        if self.timevar['tt'] is False:
            if self.flag_some_tv is True:
                return self.__tt[:, :, 0]
        return self.__tt

    def ht(self):
        """returns value for ht"""
        if self.timevar['ht'] is False:
            if self.flag_some_tv is True:
                if self.properties['ht'] in ('eye', 'diag'):
                    return self.__ht[:, 0, 0]

                return self.__ht[:, :, 0]
            else:
                if self.properties['ht'] in ('eye', 'diag'):
                    return self.__ht[:, 0]
                return self.__ht

        if self.properties['ht'] in ('eye', 'diag'):
            return self.__ht[:, 0, :]

        return self.__ht

    def cht(self):
        """returns value for the cholesky decomposion
        of ht"""

        if self.timevar['ht'] is False:
            if self.flag_some_tv is True:
                if self.properties['ht'] in ('diag', 'eye'):
                    return self.__cht[:, 0, 0]
                return self.__cht[:, :, 0]
            else:
                if self.properties['ht'] in ('diag', 'eye'):
                    return self.__cht[:, 0]
                else:
                    return self.__cht

        if self.properties['ht'] in ('diag', 'eye'):
            return self.__cht[:, 0, :]
        return self.__cht

    def cqt(self):
        """returns value for the cholesky decomposition of qt"""

        if self.timevar['qt'] is False:
            if self.flag_some_tv is True:
                return self.__cqt[:, :, 0]
        return self.__cqt

    def gqg(self):
        """returns value for the product of G(t)Q(t)G(t).T()"""

        if self.timevar['gt'] is False and self.timevar['qt'] is False:
            if self.flag_some_tv is True:
                return self.__gqg[:, :, 0]
        return self.__gqg

    def gcqt(self):
        """returns value for the product of gt and the
        Cholesky decomposition of qt"""

        if self.timevar['gt'] is False and self.timevar['qt'] is False:
            if self.flag_some_tv is True:
                return self.__gcqt[:, :, 0]
        return self.__gcqt

    def rt(self):
        """returns value for R(t)"""
        if self.timevar['rt'] is False:
            if self.flag_some_tv is True:
                if self.properties['rt'] in ('diag', 'eye'):
                    return self.__rt[:, 0, 0]
                return self.__rt[:, :, 0]
            else:
                if self.properties['rt'] in ('diag', 'eye'):
                    return self.__rt[:, 0]
                else:
                    return self.__rt

        if self.properties['rt'] in ('diag', 'eye'):
            return self.__rt[:, 0, :]
        else:
            return self.__rt

    def rhr(self):
        """returns value for the product R(t)H(t)R(t).T()"""

        #check for compressed storage
        reduced = self.properties['rt'] in ('diag', 'eye') \
                   and self.properties['ht'] in ('diag', 'eye')

        if self.timevar['rt'] is False and self.timevar['ht'] is False:
            if self.flag_some_tv is True:
                if reduced:
                    return self.__rhr[:, 0, 0]

                return self.__rhr[:, :, 0]
            else:
                #if reduced:
                #    return self.__rhr[:,0]
                return self.__rhr
        if reduced:
            return self.__rhr[:, 0, :]

        else:
            return self.__rhr

    def rcht(self):
        """returns value for the product of R(t) and the Cholesky
        decomposition of H(t)"""

        #check for compressed storage
        reduced = self.properties['rt'] in ('diag', 'eye') \
                   and self.properties['ht'] in ('diag', 'eye')

        if self.timevar['rt'] is False and self.timevar['ht'] is False:
            if self.flag_some_tv is True:
                if reduced:
                    return self.__rcht[:, 0, 0]
                else:
                    return self.__rcht[:, :, 0]
            else:
                #if reduced:
                #    return self.__rcht[:,0]
                return self.__rcht

        if reduced:
            return self.__rcht[:, 0, :]
        else:
            return self.__rcht

    def rht(self):
        """returns value for the product of R(t) and H(t)"""

        #check for compressed storage
        reduced = self.properties['rt'] in ('diag', 'eye') \
                   and self.properties['ht'] in ('diag', 'eye')

        if self.timevar['rt'] is False and self.timevar['ht'] is False:
            if self.flag_some_tv is True:
                if reduced:
                    return self.__rht[:, 0, 0]
                else:
                    return self.__rht[:, :, 0]
            else:
                #if reduced:
                #    return self.__rht[:,0]
                return self.__rht

        if reduced:
            return self.__rht[:, 0, :]
        else:
            return self.__rht

#   --------------------------------------------------------------------

    def update_properties(self, properties):
        """ Function updates the properties dictionary with new values"""
        self.properties.update(properties)

#    -------------------------------------------------------------------

    def update_rt(self, rt):
        """ Update rt and all other related matrices """

        # Store identity matrix as np.array of ones
        if self.properties['rt'] == 'eye':
            if rt.ndim == 2:
                rt = np.ones(rt.shape[0])
        # ---------------------------------------
        self.__update_rt(rt)
        self.__update_rcht()
        self.__update_rhr()

#   -------------------------------------------------------------------

    def update_ht(self, ht):
        """ Update ht and all other related matrices """
        self.__update_ht(ht)   # Note:  Updates both ht and cht
        self.__update_rcht()
        self.__update_rhr()

#   -------------------------------------------------------------------

    def update_gt(self, gt):
        """ Update gt and all other related matrices """
        self.__update_gt(gt)
        self.__update_gcqt()
        self.__update_gqg()

#   -------------------------------------------------------------------

    def update_qt(self, qt):
        """ Update qt and all other related matrices """
        self.__update_qt(qt)
        self.__update_cqt()
        self.__update_gcqt()
        self.__update_gqg()

#   --------------------------------------------------------------------

    def update_gt_qt(self, gt, qt):
        """ Update gt & qt and all other related matrices """

        self.__update_gt(gt)
        self.__update_qt(qt)
        self.__update_cqt()
        self.__update_gcqt()
        self.__update_gqg()

#   --------------------------------------------------------------------

    def update_rt_ht(self, rt, ht):
        """ Update rt and ht and all other related matrrices """

        # Store identity matrix as np.array of ones
        # ---------------------------------------
        self.__update_rt(rt)
        self.__update_ht(ht)    # Note: Updates  both ht and cht
        self.__update_rhr()
        self.__update_rcht()

#   -------------------------------------------------------------------

    def __update_rcht(self):
        """ Update rcht matrix only """

        p = self.nseries  # shortcut
        # ---------------------------------
        if self.properties['rt'] == 'eye':
            self.__rcht = self.__cht.copy()
        # -----------------------------------
        elif self.properties['ht'] == 'eye':
            self.__rcht = self.__rt.copy()
        # -----------------------------------
        else:  # Neither ht nor rt is an identity matrix
            if self.properties['rt'] == 'diag' and self.properties['ht'] == 'diag':

                if self.timevar['rt'] == self.timevar['ht']:

                    # Case1. for(t=1,..,n): for(i=1,..,p): rcht[i,0,t] = rt[i,0,t] * cht[i,0,t]
                    if self.flag_some_tv:
                        self.__rcht = self.__rt * self.__cht
                    else:
                        self.__rcht = self.rt() * self.cht()

                elif self.timevar['rt'] is True and self.timevar['ht'] is False:

                    # Case2. for(t=1,..,n): for(i=1,..,p):  rcht[i,0,t] = rt[i,0,t] * cht[i,0]
                    self.__rcht[:, 0, :] = self.__rt[:, 0, :] * self.__cht.reshape(p, 1)

                elif self.timevar['rt'] is False and self.timevar['ht'] is True:

                    # Case3. for(t=1,..,n): for(i=1,..,p): rcht[i,0,t] = rt[i,0] * cht[i,0,t)
                    self.__rcht[:, 0, :] = self.__rt * self.__cht[:, 0, :]

#           --------------------------------------------------------
            elif self.properties['rt'] == 'diag' and self.properties['ht'] != 'diag':
                if self.timevar['rt'] is False and self.timevar['ht'] is False:
                    self.__rcht = self.__rt * self.__cht
                else:
                    stdfilter.rcht_diag_rt(self.__rt, self.__cht, self.__rcht)
#           -----------------------------------------------------------
            elif self.properties['rt'] != 'diag' and self.properties['ht'] == 'diag':
                if self.timevar['rt'] is False and self.timevar['ht'] is False:
                    stdfilter.mult_dense_diag(self.__rt, self.__cht, self.__rcht)
                else:
                    stdfilter.rcht_diag_cht(self.__rt, self.__cht, self.__rcht)
#           --------------------------------------------------------
            else:  # ht and rt are not diagonal matrix
                stdfilter.rcht_dense(self.__rt, self.__cht, self.__rcht)

#   -------------------------------------------------------------------

    def __update_rhr(self):
        """ Update rhr matrix only """

        if self.properties['rt'] == 'eye':
            self.__rhr = self.__ht.copy()
        # ---------------------------------------
        elif self.properties['ht'] == 'eye':
            self.__rhr = self.__rt.copy()
        # ------------------------------------
        else:  # Neither ht nor rt is an identity matrix
# NOTE: No need to check rt & ht as identity matrices here!
            if self.properties['rt'] == 'diag' and self.properties['ht'] == 'diag':
                if self.flag_some_tv is False:
                    rhr = self.rt() * self.ht() * self.rt()
                    self.__rhr[:] = rhr.flatten()
                else:
                    stdfilter.rhr_diag_rt_ht(self._rt(), self._ht(), self._rht(), self._rhr())
               #
                #if self.timevar['rt'] == self.timevar['ht'] is False:
                #
                #    #self.__rhr = self.__rt * self.__ht * self.__rt
                #    rhr = self.rt() * self.ht() * self.rt()
                #

                #    if self.flag_some_tv is True:
                #        self.__rhr[:,0] = rhr
                #    else:
                #        self.__rhr[:] = rhr

                #    #stdfilter.rhr_diag_rt_ht(self._rt(), self._ht(), self._rht(), self._rhr())
                #
                #elif self.timevar['rt'] is True and self.timevar['ht'] is False:
                #    stdfilter.rhr_diag_rt_ht(self._rt(), self._ht(), self._rht(), self._rhr())
                #
                #elif self.timevar['rt'] is False and self.timevar['ht'] is True:
                #
                #    #self.__rhr = self.__rt.reshape(p,1) * self.__ht[:,0,:] * self.__rt.reshape(p,1)
                #    stdfilter.rhr_diag_rt_ht(self._rt(), self._ht(), self._rht(), self._rhr())

                #else:
                #    #both true

#           --------------------------------------------------------
            elif self.properties['rt'] == 'diag' and self.properties['ht'] != 'diag':
                if self.timevar['rt'] is False and self.timevar['ht'] is False:

                    rhr = self.rt()[:, np.newaxis] * self.ht() * self.rt()
                    if self.flag_some_tv is True:
                        self.__rhr[:, :, 0] = rhr
                    else:
                        self.__rhr = np.asfortranarray(rhr)

                else:
                    stdfilter.rhr_diag_rt(self.__rt, self.__ht, self.__rht, self.__rhr)
#           --------------------------------------------------------
            elif self.properties['rt'] != 'diag' and self.properties['ht'] == 'diag':
                stdfilter.rhr_diag_ht(self.__rt, self.__ht, self.__rht, self.__rhr)
#           --------------------------------------------------------
            else:  # ht and rt are not diagonal matrix
                stdfilter.rhr_dense(self._rt(), self._ht(), self._rht(), self._rhr())

#   -------------------------------------------------------------------

    def __update_ht(self, ht):
        """ Update ht and cht matrix

        arguments:
            ht - is a (nseries, nseries) matrix is the case H(t) does not change over time.
                 (nseries, nseries , nobs) np.array in the case that H(t) changes over time.
        """

        if self.properties['ht'] != 'null':
            if self.properties['ht'] == 'diag':
                ht = np.asfortranarray(np.atleast_1d(ht))
                if self.timevar['ht'] is False:
                    ht = ht.flatten()

            else:
                ht = np.asfortranarray(np.atleast_2d(ht))

            # ------------------------------------------------

            try:
                assert(ht.shape[0] == self.nseries)
            except:
                pdb.set_trace()

            # ------------------------------------------------
            if self.timevar['ht'] is True:
                if self.properties['ht'] == 'diag':

                    assert ht.shape[1] == self.nobs
                    self.__cht[:, 0, :] = np.asfortranarray(np.sqrt(ht))
                    self.__ht[:, 0, :] = np.asfortranarray(ht)

                elif self.properties['ht'] == 'inv':

                    assert(ht.shape[1] == self.nseries)
                    assert(ht.shape[2] == self.nobs)

                    if self.noname_flag is True:
                        self.__ht = np.asfortranarray(ht)
                    else:
                        info = np.array(0)

                        # Initialise:  cht = ht
                        self.__cht = np.asfortranarray(ht)

                        # Call funtion to invert each ht, i.e. set ht(:,:,t) = inv[ht(:,:,t)]
                        # Function also computes cht of each ht
                        stdfilter.compute_tv_inv_ht(self.__ht, self.__cht, info)

                        assert info == 0
                else:
                    self.__ht = np.asfortranarray(ht)
                    self.__cht = np.asfortranarray(ht.copy())
                    info = np.array(0)
                    uni.calc_chol(self.__cht, info)
                    assert info == 0
    #       --------------------------------------------------------------
            else:

                # Non time varying case
                if self.flag_some_tv is False:
                    if self.properties['ht'] == 'diag':
                        assert(ht.ndim == 1)
                        self.__cht[:, 0] = np.asfortranarray(np.sqrt(ht))
                        self.__ht[:, 0] = np.asfortranarray(ht)
                    else:
                        assert ht.ndim == 2
                        self.__ht = np.asfortranarray(ht)
                        self.__cht = np.linalg.cholesky(ht)
                else:
                    if self.properties['ht'] == 'diag':
                        assert(ht.ndim == 1)
                        self.__cht[:, 0, 0] = np.asfortranarray(np.sqrt(ht))
                        self.__ht[:, 0, 0] = np.asfortranarray(ht)
                    else:
                        assert(ht.ndim == 2)
                        self.__cht[:, :, 0] = np.asfortranarray(np.linalg.cholesky(ht))
                        self.__ht[:, :, 0] = np.asfortranarray(ht)

#   -------------------------------------------------------------------

    def __update_gqg(self):
        """ Update gqg matrix only """

        if self.properties['gt'] == 'eye':
            assert self.nstate == self.rstate
            self.__gqg = self.__qt.copy()
        else:
            if self.timevar['gt'] is True or self.timevar['qt'] is True:
                uni.update_gqg(self.__gqg, self.__qt, self.__gqt, self.__gt)
            else:
                if self.flag_some_tv is True:
                    qtgt = np.dot(self.__qt[:, :, 0], self.__gt[:, :, 0].T)
                    self.__gqg[:, :, 0] = np.asfortranarray(np.dot(self.__gt[:, :, 0], qtgt))
                else:
                    self.__gqg = np.asfortranarray(np.dot(self.__gt,
                                      np.dot(self.__qt, self.__gt.T)))

#   -------------------------------------------------------------------

    def __update_gcqt(self):
        """ Update gcqt matrix only """

        if self.properties['gt'] == 'eye':
            assert self.nstate == self.rstate
            self.__gcqt = np.asfortranarray(self.__cqt.copy())
        else:
            if self.timevar['gt'] is True or self.timevar['qt'] is True:
                uni.update_gtcqt(self.__gcqt, self.__gt, self.__cqt)
            else:
                if self.flag_some_tv is True:
                    self.__gcqt[:, :, 0] = np.asfortranarray(np.dot(self.__gt[:, :, 0],
                                               self.__cqt[:, :, 0]))
                else:
                    self.__gcqt = np.asfortranarray(np.dot(self.__gt,
                                                  self.__cqt))

#   -------------------------------------------------------------------

    def __update_rt(self, rt):
        """ Update rt matrix only """

        if self.timevar['rt'] is True:
            if self.properties['rt'] == 'diag' or self.properties['rt'] == 'eye':

                self.__rt[:, 0, :] = np.asfortranarray(np.atleast_1d(rt))
            else:
                self.__rt = np.asfortranarray(np.atleast_2d(rt))

            assert(self.__rt.shape[0] == self.nseries)
        else:
            if self.properties['rt'] == 'diag' or self.properties['rt'] == 'eye':
                if self.flag_some_tv is False:
                    self.__rt[:, 0] = np.asfortranarray(np.atleast_1d(rt))
                else:
                    self.__rt[:, 0, 0] = rt
            else:
                if self.flag_some_tv is False:
                    self.__rt = np.asfortranarray(np.atleast_2d(rt))
                else:
                    self.__rt[:, :, 0] = np.asfortranarray(np.atleast_2d(rt))

#   --------------------------------------------------------------------

    def __update_qt(self, qt):
        """ Update qt matrix only.
        Note:
            qt - Is an (rstate, rstate) matrix in the case Q(t) does not change over time
                 and is an (rstate, rstate, nobs) np.array in the case that Q(t) changes
                 over time.
        """

        qt = np.asfortranarray(np.atleast_2d(qt))
        assert(qt.shape[0] == self.rstate)
        assert(qt.shape[1] == self.rstate)

        if self.timevar['qt'] is True:
            assert(qt.shape[2] == self.nobs)
            self.__qt = np.asfortranarray(qt)
        else:
            assert(qt.ndim == 2)
            if self.flag_some_tv is False:
                self.__qt = np.asfortranarray(qt)
            else:
                self.__qt[:, :, 0] = np.asfortranarray(qt)

#   --------------------------------------------------------------------

    def __update_cqt(self):
        """ Update cqt matrix only """

        qt = self.qt()  # Take correct bit if not time varying, else take all

        if self.timevar['qt'] is True:
            self.__cqt = np.asfortranarray(qt.copy())
            info = np.array(0)
            uni.calc_chol(self.__cqt, info)
            if info != 0:
                print "Error: Cholesky decomposition failed [__update_cqt]"
                sys.exit(0)
        else:
            if self.flag_some_tv is False:
                self.__cqt = np.asfortranarray(np.linalg.cholesky(qt))
            else:
                self.__cqt[:, :, 0] = np.asfortranarray(np.linalg.cholesky(qt))

#   --------------------------------------------------------------------

    def __update_gt(self, gt):
        """ Function updates the G(t) matrix only.

        arguments:
            gt - Is an (nstate, rstate) matrix in the case that G(t)
                 does not change over time, otherwise G(t) is an
                 (nstate, rstate, nobs) np.array.
        """

        gt = np.asfortranarray(np.atleast_2d(gt))
        # ----------------------------------------
        assert(gt.shape[0] == self.nstate)
        assert(gt.shape[1] == self.rstate)
        # ---------------------------------------
        if self.timevar['gt'] is True:
            assert(gt.shape[2] == self.nobs)
            self.__gt = np.asfortranarray(gt)
        else:
            assert(gt.ndim == 2)
            if self.flag_some_tv is False:
                self.__gt = np.asfortranarray(gt)
            else:
                self.__gt[:, :, 0] = np.asfortranarray(gt)

#   --------------------------------------------------------------------

    def update_tt(self, tt):
        """Function to update the transition matrix T(t).

        arguments:
            tt - Is an (nstate, nstate) matrix in the case that T(t) does
                 not change over time and is an (nstate, nstate, nobs) np.array
                 in the case that T(t) changes over time.
        """

        tt = np.asfortranarray(np.atleast_2d(tt))

        assert(tt.shape[0] == self.nstate)
        assert(tt.shape[1] == self.nstate)

        if self.timevar['tt'] is True:
            assert tt.shape[2] == self.nobs
            self.__tt = np.asfortranarray(tt)
        else:
            if self.flag_some_tv is False:
                self.__tt = np.asfortranarray(tt)
            else:
                self.__tt[:, :, 0] = np.asfortranarray(tt)

#   --------------------------------------------------------------------

    def update_zt(self, zt):
        """Function that updates the system matrix Z(t).

        arguments:
            zt - Is a (nseries, nstate) matrix in the case that
                 Z(t) does not change over time and is an
                 (nseries, nstate, nobs) np.array in the case that
                 Z(t) changes over time.
        """

        zt = np.asfortranarray(np.atleast_2d(zt))

        assert(zt.shape[0] == self.nseries)
        assert(zt.shape[1] == self.nstate)

        if self.timevar['zt'] is True:
            assert zt.shape[2] == self.nobs
            self.__zt = np.asfortranarray(zt)
        else:
            if self.flag_some_tv is False:
                self.__zt = np.asfortranarray(zt)
            else:
                self.__zt[:, :, 0] = np.asfortranarray(zt)

#   --------------------------------------------------------------------

    def update_a1(self, a1):
        """Function updates the mean of the inital state, a1

        arguments:
            a1 - Is a vector of order nstate.
        """
        a1 = np.asfortranarray(np.atleast_1d(a1))
        assert(a1.shape[0] == self.nstate)
        self.__a1 = a1

#   --------------------------------------------------------------------

    def update_p1(self, p1):
        """Function updates the covariance matrix of the intial state,
        p1.

        arguments:
            p1 - Is an (nstate, nstate) matrix.
        """

        p1 = np.asfortranarray(np.atleast_2d(p1))

        assert(p1.shape[0] == self.nstate)
        assert(p1.shape[1] == self.nstate)
        self.__p1 = np.asfortranarray(p1)
        try:
            self.__cholp1 = np.asfortranarray(np.linalg.cholesky(p1))
        except:
            if (p1 == 0.0).all():
                self.__cholp1 = p1.copy()
            else:
                raise ValueError("Cholesky decomposition failed in p1 update")

#   --------------------------------------------------------------------

    def transform_zt(self, cholinvH, **kwargs):
        """
        zt is pre multiplied by cholinvH, to transform the measurement
        equation so the that univariate filtering equations can be
        used. cholinvH must be the upper triangle from the cholesky
        decomposition of inverse of H. The user can optionally pass a
        vector of equal dimension to the state. This is used to scale
        the columns of Z, to overparameterise the model. The
        paramterisation has to be reversed post estimation using the
        transform option in MCMC. Do not use this feature if you dont
        know what you are doing.
        """

        cholinvH = np.asfortranarray(cholinvH)
        if self.flag_some_tv is False:
            self.update_zt(np.dot(cholinvH, self.__zt))

        else:
            uni.transform_u(cholinvH, self.__zt)

        if 'scale' in kwargs:
            scale = np.atleast_1d(kwargs['scale'])
            assert scale.ndim == 1
            assert scale.shape[0] == self.nstate

            if self.flag_some_tv is False:
                uni.scale_z(self.__zt, scale)

            else:
                uni.scale_ztv(self.__zt, scale)

    def get_properties(self):
        return self.properties

# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


class FilterBase:
    """Class provides filtering and classical smoothing algorithms for the SSM,
    where the SSM is specified following:

        y(t) = Z(t) * state(t) + R(t) *epsilon(t); epsilon(t) ~ N(0, H(t)),
        for t = 1, 2, ..., nobs, and the state is generated by

        state(t+1) = T(t) * state(t) + G(t) * eta(t); eta(t) ~ N(0, Q(t)),
        for t=1, 2, ..., nobs - 1.

    arguments:

        nobs - An integer specifing the number of time series observations.

        nseries - An integer specifing the number of time series.

        nstate - An integer specifying the dimension of the state vector.

        rstate - An integer specifying the dimension ot Q(t).

        timevar - A boolean that is True is the state space is time-varying ir
                  False otherwise. Note if any of the system matrices change over
                  time then this argument must be True.

    optional arguments(**kwargs):
        filter - specfies what filtering algorithm to use. There are two options.
                 Namely 'dkbenchmark', 'c_filter'. If no options are specfied then
                 the default filtering algorithm is used. Note that 'dkbenchmark'
                 refers to a filter that is implemented following Durbin and Koopman
                 (2001), without any alteration. This algorithm can be very inefficient and
                 only should be used for benchmarking. The algorithm 'c_filter' is the
                 contemporaneous version of the Kalman filter.

        smoother - By default the state smoother is used, however there is the option of
                   using a disturbance smoother. Thie is used simply through the option
                   'disturbance'.


        properties - Allows for certain optimisations. The input should be a dictionary
                     specifing structure in certain matrices that allow for certain
                     optimisations. Allowable options are listed below with the keyword
                     on the left and the property on the right. Note that the optimisations
                     will only effect certain algorithms, so there is no guarantee of any
                     performance gain. It is unlikely to lead to any performance loss
                     however so if known this information should be included.

                     'ht': 'diag'
                         Note this option can be used if H(t) is a diagonal matrix. In
                         this case only the diagonal for H(t).

                     'gt': 'eye'
                         Note this option can be used when G(t) is an identity matrix.

                     'tt': 'eye'
                         Note that this option can be used when G(t) is an identity matrix.

    public member functions:
        initialise_system(a1, p1, zt, ht, tt, gt, qt) - Initialises system matrices for
                                                        filtering algorithms.

        get_ymat() - Function returns that (nseries, nobs) data set.

        get_state() - Function returns the (nstate, nobs) state.

        update_ymat(ymat) - Function updates the class copy of ymat.

        simssm() - Function simulates data from the specified SSM.

        log_likelihood() - Function returns the log-likelihood for the SSM.

        filter() - Function runs the specified filtering algorithm.

        smoother() - Function runs the specified smoothing algorithm.

    """

    def __init__(self, nobs, nseries, nstate, rstate, timevar, **kwargs):
        self.sreg, self.nreg = 0., 0.
        self.nseries = nseries
        self.nobs = nobs
        self.nstate = nstate
        self.rstate = rstate
        self.state = np.zeros((nstate, nobs), order='F')
        self.ymat = np.zeros((self.nseries, self.nobs), order='F')
        self.init_sys = False
        self.rand_meas = np.zeros(nseries)
        self.rand_state = np.zeros((rstate, nobs), order='F')
        self.state_error = np.zeros((nstate, nobs), order='F')

        #Place holders use in the case of missing data
        self.partial_missing = np.zeros(self.nobs, dtype='i')
        self.flag_missing = None

        #Note flag_nmissing -
        #   None - No missing data
        #   1 - Missing data only over entire columns of ymat
        #   2 - Missing data over partial column of ymat

        #Note missing in kwargs required to tell if ymat is going to inclued
        #missing data
        if 'missing' in kwargs and kwargs['missing'] is True:
            self.flag_missing = True
        #Flag required for disturbance simulation smoother
        self.sim_d_flag = False
        if 'sim_disturbance' in kwargs and kwargs['sim_disturbance'] is True:
            self.sim_d_flag = True

        #storage needed for filtering and smoothing
        self.rvec = np.zeros(nstate)
        self.ltr = np.zeros(nstate)
        self.jt = np.zeros((rstate, nstate, nobs), order='F')
        self.timevar = timevar
        self.filter_type = 'stdfilter'
#       ----------------------------------------------------------------
        if 'smoother' in kwargs:
            if kwargs['smoother'] == 'disturbance':
                self.smoother_type = 'disturbance'
                self.ehat = np.zeros((rstate, nobs), order='F')
                self.ahat = np.zeros((nstate, nobs), order='F')
            else:
                self.smoother_type = 'state'
                self.ahat = np.zeros((nstate, nobs), order='F')
        else:
            self.smoother_type = 'state'
            self.ahat = np.zeros((nstate, nobs), order='F')
#       ----------------------------------------------------------------
        self.loglike = np.zeros(1)
        self.ilike = 1
#       ----------------------------------------------------------------
        if 'noname' in kwargs and kwargs['noname'] is True:
            self.noname_flag = True
        else:
            self.noname_flag = False
#       ----------------------------------------------------------------
        if 'filter' in kwargs.keys():
            if kwargs['filter'] == 'dkbenchmark':
                # filter used only for benchmarking. Based on algorithms in Durbin and koopman 2001
                self.filter_type = 'dkbenchmark'
                timevar = True
                self.unifilter = False
                self.inverse_f = np.zeros((nseries, nseries, nobs), order='F')
                self.wz = np.zeros((nstate, nseries), order='F')
                self.fn = np.zeros(nseries)
            elif kwargs['filter'] == 'c_filter':
                self.filter_type = kwargs['filter']
            else:
                self.filter_type = 'stdfilter'
#       ----------------------------------------------------------------

        self.unifilter = False
        ht_diag = False
        rt_diag = False

        if 'properties' in kwargs.keys():
            if 'ht' in kwargs['properties']:
                if kwargs['properties']['ht'] in ['diag', 'eye']:
                    ht_diag = True

        if 'properties' in kwargs.keys():
            if 'rt' in kwargs['properties']:
                if kwargs['properties']['rt'] in ['diag', 'eye']:
                    rt_diag = True

        if ht_diag is True and rt_diag is True:
            if self.sreg + self.nreg == 0:
                self.filter_type = 'unifilter'
                self.unifilter = True

#       ----------------------------------------------------------------
        if 'properties' in kwargs.keys():
            assert type(kwargs['properties']) == type({})
            properties = kwargs['properties']
        else:
            properties = {}
#       ----------------------------------------------------------------
        self.sys = System(nobs, nseries, nstate, rstate, timevar,
                         self.noname_flag, properties, self.flag_missing)
        self.flag_some_tv = self.sys.flag_some_tv

#       ----------------------------------------------------------------
        self.properties_tt = 0  # tt is dense
        properties = self.sys.get_properties()
        if properties['tt'] == 'eye':
            self.properties_tt = 1
#       ----------------------------------------------------------------
        if self.filter_type == 'c_filter':
            self.astore = np.zeros((nstate, nobs + 1), order='F')
            self.pstore = np.zeros((nstate, nstate, nobs + 1), order='F')
        else:
            self.astore = np.zeros((nstate, nobs), order='F')
            self.pstore = np.zeros((nstate, nstate, nobs), order='F')
#       ----------------------------------------------------------------

        if self.filter_type != 'unifilter':
            self.nustore = np.zeros((nseries, nobs), order='F')
            self.ft = np.zeros((nseries, nseries), order='F')
            self.sstore = np.zeros((nseries, nstate, nobs), order='F')

            if self.filter_type == 'c_filter':
                self.mt = np.zeros((nseries, nstate), order='F')
                self.at_t = np.zeros((nstate, nobs), order='F')
                self.pt_t = np.zeros((nstate, nstate, nobs), order='F')
                self.work = np.zeros((nstate, nstate, nobs), order='F')
            else:
                self.mt = np.zeros((nstate, nseries), order='F')
                self.lstore = np.zeros((nstate, nstate, nobs), order='F')
                self.kstore = np.zeros((nstate, nseries, nobs), order='F')
                self.work = np.zeros((nstate, nstate), order='F')
            self.info = np.array(0)
            self.work_like = np.zeros(nseries)

        else:  # i.e. filter_type == 'unifilter'
            self.nustore_fstore = np.zeros((nseries, nobs, 2), order='F')
            self.kstore = np.zeros((nstate, nseries, nobs), order='F')
            self.pttt = np.zeros((nstate, nstate), order='F')
            if self.flag_some_tv is False:
                self.lt = np.zeros((nstate, nstate, nseries), order='F')
                self.mt = np.zeros((nstate, nseries), order='F')
            else:
                self.lt = np.zeros((nstate, nstate), order='F')
                self.mt = np.zeros(nstate)
#       ----------------------------------------------------------------
        if self.flag_some_tv is False:
            self.last_t = np.array(0, dtype='i')
#       ----------------------------------------------------------------
        if self.filter_type == 'unifilter':
            if self.flag_some_tv is False:
                self._filter = self.__unifilter_ntv
                self._smoother = self.__unismoother_ntv
                self._simulate_ssm = self.__simulate_uni_ssm_ntv
            else:
                self._filter = self.__unifilter_tv
                self._smoother = self.__unismoother_tv
                self._simulate_ssm = self.__simulate_uni_ssm_tv

        elif self.filter_type == 'stdfilter':
            if self.flag_some_tv is False:
                self._filter = self.__filter_ntv
                if self.smoother_type == 'state':
                    self._smoother = self.__smoother_ntv
                else:
                    self._smoother = self.__disturbance_smoother_ntv
                self._simulate_ssm = self.__simulate_ssm_ntv
            else:
                self._filter = self.__filter_tv
                if self.smoother_type == 'state':
                    self._smoother = self.__smoother_tv
                else:
                    self._smoother = self.__disturbance_smoother_tv
                self._simulate_ssm = self.__simulate_ssm_tv

        elif self.filter_type == 'dkbenchmark':
            self._filter = self.__filter_bm
            self._smoother = self.__smoother_bm

            self._simulate_ssm = self.__simulate_ssm_tv

        elif self.filter_type == 'c_filter':
            if self.flag_some_tv is False:
                self._filter = self.__cfilter_ntv
                self._smoother = self.__csmoother_tv  # note same as tv case
                self._simulate_ssm = self.__simulate_ssm_ntv
            else:
                self._filter = self.__cfilter_tv
                self._smoother = self.__csmoother_tv
                self._simulate_ssm = self.__simulate_ssm_tv
#       ----------------------------------------------------------------
        if self.flag_some_tv is True:
            self._gen_state = self.__gen_state_tv
        else:
            self._gen_state = self.__gen_state_ntv

#   ----------------------------------------------------------------------

    def initialise_system(self, a1, p1, zt, ht, tt, gt, qt, rt):
        """Function is used to initialise the SSM.

        arguments:
            a1 - Is an vector of order nstate. It is the mean of the
                 initial state.

            p1 - Is an (nstate, nstate) matrix. It is the covariance
                 matrix for the initial state.

            zt - Is an (nseries, nstate) matrix in the case that Z(t)
                 does not change over time, otherwise it is an
                 (nseries, nstate, nobs) np.array.

            ht - Is an (nseries, nseries) matrix if H(t) does not
                 change over time and the property for H(t) was not
                 set to 'diag'. If the property (see properties option
                 for Filter above) was se to 'diag' then
                 ht is a vector of order nseries. For the case where
                 H(t) changes over time and the property for H(t) was
                 not set to 'diag' then ht is an (nseries, nseries, nobs)
                 np.array. In the case it the property option is set to 'diag'
                 then ht should be an (nseries, nobs) np.array.

            tt - Is an (nstate, nstate) matrix in the case T(t) does not
                 change over time and is an (nstate, nstate, nobs) np.array
                 otherwise.

            gt - Is an (nstate, rstate) matrix in the case G(t) does not
                 change through time and is an (nstate, rstate, nobs) np.array
                 otherwise.

            qt - is an (rstate, rstate) matrix in the case Q(t) does not
                 change over time and is an (rstate, rstate, nobs) np.array
                 otherwise.

            rt - is an (nseries, nseries) matrix in non time varying case
                 or (nseries, nseries, nobs) in time varying case.
                 if properties['rt'] == 'diag' of 'eye' then rt is a
                 vector of order nseries in the non-timevarying case and
                 is a (nseries, nobs) matrix in the timevarying case.

        """

        self.sys.update_zt(zt)
        self.sys.update_tt(tt)
        self.sys.update_rt_ht(rt, ht)
        self.sys.update_gt_qt(gt, qt)
        self.sys.update_a1(a1)
        self.sys.update_p1(p1)

        self.init_sys = True

#   ----------------------------------------------------------------------

    def get_system(self):
        """Function get_system returns the class system."""
        return self.sys

#   ----------------------------------------------------------------------

    def get_ymat(self):
        """Function returns the (nseries, nobs) observational matrix"""
        return self.ymat

#   ----------------------------------------------------------------------

    def get_state(self):
        """Function returns the (nstate, nobs) state vector"""
        return self.state

#   ----------------------------------------------------------------------

    def update_ymat(self, ymat, **kwargs):
        """Function can be used to update ymat

        arguments:
            ymat - Is an (nseries, nobs) matrix ymat

        optional arguments:
            check_missing - If True,  checks for nan in data, where nan is used
                            to represent missing data. Algorithms are modified
                            accordingly.
        """
        self.ymat = np.asfortranarray(np.atleast_2d(ymat))

        missing = 'check_missing' in kwargs and kwargs['check_missing'] is True

        if missing or self.flag_missing:
            stdfilter.ck_col_nan(self.ymat, self.partial_missing)

            if all(self.partial_missing == 0):
                #No missing data
                self.flag_missing = None
            elif all(self.partial_missing != 1):
                #Missing data but if missing entire column of ymat missing
                self.flag_missing = 2
            else:
                #Partial missing data
                self.flag_missing = 1
                #Note covariance needs to be diagonalised in measurement
                #equation to handle this case. Not yet implemented

#   ----------------------------------------------------------------------

    def simssm(self):
        """Function simulates from the data generating process for the SSM"""

        #Check to ensure simulation smoother class has been initialised
        try:
            assert(self.init_sys is True)
        except:
            error = """SimSmoother class has not been initialised. You need to
            call self.initilise_system first."""
            raise Exception(error)

        self.rand_meas = np.asfortranarray(np.random.randn(self.nseries, self.nobs))
        self.rand_state = np.asfortranarray(np.random.randn(self.rstate, self.nobs))
        self.state[:, 0] = np.asfortranarray(self.sys._a1() + np.dot(self.sys._cholp1().T, np.random.randn(self.nstate)))

        self._simulate_ssm()

#   ----------------------------------------------------------------------

    def log_likelihood(self):
        return self._log_likelihood()

    def _log_likelihood(self):
        """Function evalutates and returns the log-likelihood"""
        self.ilike = 0
        self.filter()
        self.ilike = 1

        temp = self.nseries * self.nobs * np.log(2.0 * np.pi) * 0.5
        return self.loglike - temp

#   ----------------------------------------------------------------------

    def __simulate_uni_ssm_tv(self):
        """Used when both H(t) and R(t) are diagonal, and at
        least one of the system matrices is timevarying"""

        cht = self.sys._rcht()  # Replace cht with rcht
        uni.simssm(self.ymat, self.sys._zt(), cht, self.sys.tt(),
                    self.sys._gcqt(),  self.rand_meas,
                    self.rand_state, self.state)

#   ----------------------------------------------------------------------

    def __simulate_uni_ssm_ntv(self):
        """Used when both H(t) and R(t) are diagonal, and
        none of the system matrices is timevarying"""

        cht = self.sys._rcht()  # Replace cht with rcht
        uni.ntsimssm(self.ymat, self.sys._zt(), cht,
                  self.sys.tt(), self.sys._gcqt(), self.rand_meas, self.rand_state, self.state)

#   ----------------------------------------------------------------------

    def __simulate_ssm_tv(self):
        """Used to simulate data for the state space model when at
        least one of the system matrices is time varying"""

        if self.sim_d_flag is True:
            gcqt = self.sys._gt()
        else:
            gcqt = self.sys._gcqt()

        stdfilter.calc_st_er(gcqt, self.sys._cqt(), self.rand_state, self.state_error,
                            self.sim_d_flag)
        cht = self.sys._rcht()  # Replace cht with rcht

        stdfilter.simssm(self.ymat, self.sys._zt(), cht, self.sys._tt(), self.state_error,
                         self.rand_meas, self.state)

#   ----------------------------------------------------------------------

    def __simulate_ssm_ntv(self):
        """Used to simulate data from the state space model when none
        of the system matrices are time varying"""

        if self.sim_d_flag is True:
            gcqt = self.sys._gt()
        else:
            gcqt = self.sys._gcqt()
        stdfilter.nt_calc_st_er(gcqt, self.sys._cqt(), self.rand_state, self.state_error,
                               self.sim_d_flag)
        cht = self.sys._rcht()  # Replace cht with rcht
        stdfilter.ntsimssm(self.ymat, self.sys._zt(), cht, self.sys._tt(), self.state_error,
                         self.rand_meas, self.state)

#   ----------------------------------------------------------------------

    def filter(self):
        """Function runs the filtering algorithm"""
        self._filter()

#   ----------------------------------------------------------------------

    def __filter_ntv(self):
        """Used by the filtering algoritm when none of the
        system matrices are time varying."""

        #Ensures there are no missing data as it is not compatible
        #with this specification.
        try:
            assert self.flag_missing is None
        except:
            error = """You need to tell the class Filter that missing = True
            on initialisation if you have missing data."""

            raise Exception(error)

        self.loglike[0] = 0.0
        at = self.sys._a1().copy()
        pt = np.asfortranarray(self.sys._p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr

        stdfilter.ntfilter(self.ymat, self.sys._zt(), ht, self.sys._tt(), self.sys._gqg(),
                           self.nustore, self.kstore, self.ft, self.sstore, self.astore, at,
                           pt, self.pstore, self.mt, self.work, self.lstore, self.last_t,
                           self.loglike, self.work_like, self.info, self.ilike)
        assert(self.info == 0)

#   ---------------------------------------------------------------------

    def __time_t(self, a, t):
        """Helper function that obtains the correct index for a system
        matrix when at least one of the system matrices are time varying."""

        if a.shape[a.ndim - 1] == 1:
            return 0
        else:
            return t

#   ----------------------------------------------------------------------

    def __filter_tv(self):
        """Helper function for filter when at least one of the system
        matrices is time varying"""

        #Ensure that columns of y don't include partial missing data
        try:
            assert self.flag_missing != 1
        except:
            error = """If missing data is present in the data either the
            whole column of y must be missing or R(t) and H(t) must both
            be diagonal"""
            raise NotImplementedError(error)

        self.loglike[0] = 0.0
        at = self.sys._a1().copy()
        pt = np.asfortranarray(self.sys._p1().copy())

        ht = self.sys._rhr()

        stdfilter.filter(self.ymat, self.sys._zt(), ht, self.sys._tt(), self.sys._gqg(),
                         self.nustore, self.kstore, self.ft, self.sstore, self.astore, at,
                         pt, self.pstore, self.mt, self.work, self.lstore, self.loglike,
                         self.work_like, self.info, self.properties_tt, self.ilike,
                         self.partial_missing)

        assert(self.info == 0)

#   ----------------------------------------------------------------------

    def __cfilter_tv(self):
        """Helper function for the contemperaneous filter when at least one
        of the system matrices is time varying"""

        self.loglike[0] = 0.0
        self.astore[:, 0] = self.sys._a1().copy()
        self.pstore[:, :, 0] = np.asfortranarray(self.sys._p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr

        stdfilter.cfilter(self.ymat, self.sys._zt(), ht, self.sys._tt(),
                         self.sys._gqg(), self.nustore, self.ft, self.sstore, self.astore,
                         self.at_t, self.pt_t, self.pstore, self.mt, self.work, self.loglike,
                         self.work_like, self.info, self.ilike)
        assert(self.info == 0)

#   ----------------------------------------------------------------------

    def __cfilter_ntv(self):
        """Helper function for the contemperaneous version of the Kalman filter
        if none of the system matrices are time varying"""

        self.loglike[0] = 0.0
        self.astore[:, 0] = self.sys._a1().copy()
        self.pstore[:, :, 0] = np.asfortranarray(self.sys._p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr

        stdfilter.ntcfilter(self.last_t, self.ymat, self.sys._zt(), ht, self.sys._tt(), self.sys._gqg(),
                         self.nustore, self.ft, self.sstore, self.astore,  self.at_t,
                         self.pt_t, self.pstore, self.mt, self.work, self.loglike,
                         self.work_like, self.info, self.ilike)

        assert(self.info == 0)

#   ----------------------------------------------------------------------

    def __filter_bm(self):
        """Helper function for the benchmark filter"""
        at = self.sys._a1().copy()
        pt = np.asfortranarray(self.sys._p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr

        stdfilter.bfilter(self.ymat, self.sys._zt(), ht, self.sys._tt(), self.sys._gqg(),
                         self.nustore, self.kstore, self.ft, self.inverse_f,  self.wz,
                          self.astore, at, pt, self.pstore, self.mt,
                          self.work, self.lstore, self.info, self.ilike)
        assert(self.info == 0)

#   ----------------------------------------------------------------------

    def __unifilter_ntv(self):
        """univariate filtering algorithm for SSM with non time varying system matricies"""
        self.loglike[0] = 0.0
        at = self.sys._a1().copy()
        pt = np.asfortranarray(self.sys._p1().copy())

        ht = self.sys._rhr()  # Replace ht with rhr
        uni.ntunifilter(self.ymat, self.nustore_fstore, self.kstore, self.astore, self.pstore,
                        at, pt, self.sys._zt(), ht, self.mt, self.sys._tt(), self.sys._gqg(),
                        self.pttt, self.last_t, self.loglike, self.ilike)

#   ----------------------------------------------------------------------

    def __unifilter_tv(self):
        """univariate filtering algorithm for SSM with time varying system matricies"""
        self.loglike[0] = 0.0
        at = self.sys._a1().copy()
        pt = np.asfortranarray(self.sys._p1().copy())

        # Replace ht with rhr
        ht = self.sys._rhr()

        uni.unifilter(self.ymat, self.nustore_fstore, self.kstore, self.astore, self.pstore,
                      at, pt, self.sys._zt(), ht, self.mt, self.sys._tt(), self.sys._gqg(),
                      self.pttt, self.loglike, self.properties_tt, self.ilike)

#   ----------------------------------------------------------------------

    def disturbance_smoother(self):
        """Function runs the disturbance smoother"""
        self.filter()
        self.__disturance_smoother(self)

#   ----------------------------------------------------------------------

    def __disturbance_smoother_tv(self):
        """Helper function for the disturbance smoother when at least one of
        the system matrices is time varying."""

        self.update_jt()
        stdfilter.dsmoother(self.ehat, self.nustore, self.sstore, self.jt, self.rvec,
                            self.lstore, self.ltr,
                            self.partial_missing)

#   ----------------------------------------------------------------------

    def __disturbance_smoother_ntv(self):
        """Helper function for the disturbance smoother when none of the
        system matrices are time varying"""

        self.update_jt()
        stdfilter.ntdsmoother(self.ehat, self.nustore, self.sstore, self.jt, self.rvec,
                            self.lstore, self.ltr, self.last_t)

#   ----------------------------------------------------------------------

    def gen_state(self):
        """Function generates the state vector based on the disturbances"""
        #pdb.set_trace()
        self._gen_state()
        return self.ahat

#   ----------------------------------------------------------------------

    def __gen_state_tv(self):
        """Helper function for generating the state when at least one of the
        system matrices is time varying"""

        self.ahat[:, 0] = self.sys._a1() + np.dot(self.sys._p1(), self.rvec)
        stdfilter.genstate(self.ehat, self.sys._tt(), self.sys._gt(), self.ahat)

#   ----------------------------------------------------------------------

    def __gen_state_ntv(self):
        """Helper function for generating the state when none of the system matrices
        are time varying."""

        self.ahat[:, 0] = self.sys._a1() + np.dot(self.sys._p1(), self.rvec)
        stdfilter.ntgenstate(self.ehat, self.sys._tt(), self.sys._gt(), self.ahat)

#   ----------------------------------------------------------------------

    def smoother(self):
        """Function runs the smoothing algorithm"""
        self.filter()
        self._smoother()

#   ----------------------------------------------------------------------

    def __unismoother_tv(self):
        """Helper function for smoothing when both H(t) and R(t) are diagonal
        and at least one of the system matrices is time varying"""

        uni.unismoother2(self.ahat, self.kstore, self.astore, self.pstore, self.rvec,
                self.sys._tt(), self.sys._zt(), self.ltr, self.nustore_fstore,
                        self.properties_tt, self.ymat)

#   ----------------------------------------------------------------------

    def __unismoother_ntv(self):
        """Helper function for smoothing when both H(t) and R(t) are diagonal
        and none of the system matrices are time varying."""

        uni.ntunismoother2(self.ahat, self.kstore, self.astore, self.pstore, self.rvec,
                self.sys._tt(), self.sys._zt(), self.ltr, self.nustore_fstore,
                self.last_t)

#   ----------------------------------------------------------------------

    def __smoother_tv(self):
        """is used for time varying system matrices"""

        #Ensure that columns of y don't include partial missing data
        try:
            assert self.flag_missing != 1
        except:
            error = """If missing data is present in the data either the
            whole column of y must be missing or R(t) and H(t) must both
            be diagonal"""
            raise NotImplementedError(error)

        ind = 1
        if ind == 0:
            self.rvec = np.zeros(self.nstate)
            for t in np.reversed(xrange(self.nobs)):
                self.rvec = np.dot(self.sstore[:, :, t].T, self.nustore[:, t]) + \
                        np.dot(self.lstore[:, :, t].T, self.rvec)
                self.ahat[:, t] = self.astore[:, t] + np.dot(self.pstore[:, :, t], self.rvec)
        else:
            stdfilter.smoother(self.ahat, self.sstore, self.nustore, self.lstore, self.rvec,
                           self.ltr, self.astore, self.pstore, self.partial_missing)

#   ----------------------------------------------------------------------

    def __csmoother_tv(self):
        print "No classical smoothing algorithm is implemented for the contemporaneous\
                filtering equation. If you wish to use the classical smoothing\
                use an alternative filtering algorithm or simulation smoothing algorithm."
        sys.exit(0)

#   ----------------------------------------------------------------------

    def __smoother_ntv(self):
        """is used for non time varying system
        matrices"""

        stdfilter.ntsmoother(self.ahat, self.sstore, self.nustore, self.lstore, self.rvec,
                             self.ltr, self.astore, self.pstore, self.last_t)

#   ----------------------------------------------------------------------

    def __smoother_bm(self):
        """is used for time varying system matrices"""
        stdfilter.bsmoother(self.ahat, self.sys._zt(), self.inverse_f, self.fn, self.nustore,
                            self.lstore, self.rvec, self.ltr, self.astore, self.pstore)

#   ----------------------------------------------------------------------

    def update_jt(self):
        """Helper function for deJong and Shephard simulation smoother."""
        system = self.get_system()
        if system.flag_some_tv is True:
            stdfilter.update_jt(self.jt, system._qt(), system._gt())
        else:

            self.jt = np.asfortranarray(np.dot(system._qt(), system._gt().T))


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------

class SimSmootherBase:
    """Class for simulation smoothing for the SSM. It is assumed that the
    SSM is generated according to,

        y(t) = Z(t) * state(t) + R(t) * epsilon(t); epsilon(t) ~ N(0, H(t)),
        for t = 1, 2, ..., nobs, and the state is generated by

        state(t+1) = T(t) * state(t) + G(t) * eta(t); eta(t) ~ N(0, Q(t)),
        for t=1, 2, ..., nobs - 1.

        The initial state is distributed such that state(1) ~ N(a1, p1).

    arguments:
        ymat - Is an (nseries, nobs) matrix of observations.

        nstate - Is an integer specifying the dimension of the state vector.

        rstate - Is an integer specifying the dimension of Q(t).

        timevar - A boolean that is True is the state space is time-varying ir
                  False otherwise. Note if any of the system matrices change over
                  time then this argument must be True.


    public member functions:
        initialise_system(a1, p1, zt, ht, tt, gt, qt, rt) - Initiases system matrix.

        sim_smoother() - Runs simulation smoother and returns simulated state vector.

        log_likelihood() - Returns log-likelihood for SSM.

        update_ymat(ymat) - Updates (nseries, nobs) np.array for the observations.

        get_ymat() - Returns the (nseries, nobs) matrix of observations.

        get_system() - Returns the class that stores the system matrices.

        get_state() - Returns the simulated state vector.

        get_state_residual(**kwargs) - returns the (rstate, nobs) matrix of residuals
                                       for the state.

                                       optional argument(**kwargs):
                                           state_index - An index specifying what elements
                                           of the state vector that you want the residuals
                                           for.

                                           For example if you want the first three
                                           elements of the state, then

                                           state_index = np.array([0,1,2]) is passed to the
                                           function.

        get_meas_residual() - Returns the residuals from the measurement equation of the
                              SSM.

        get_zt_times_state() - returns the (nseries * nobs) np.array Zt * state.

        log_probability_state(**kwargs) - Returns the log  probabiltiy of the simulated
                                          state.

                                          optional arguments:
                                              state_index - An index specifying a subset
                                              of the state that you what to evaluate the
                                              probability of.

        log_probability_meas() - Returns the log probability of the measurement equation
                                given the state vector and the system matricies.

    """

#   --------------------------------------------------------------------

    def __init__(self, ymat, nstate, rstate, timevar, **kwargs):
        if ymat.ndim == 1:
            ymat = ymat.reshape(1, ymat.shape[0])
        nseries, nobs = ymat.shape
        self.stateplus = np.zeros((nstate, nobs), order='F')
        self.ymat = ymat.copy()

        self.benchmark_filter = False
        if type(timevar) == type({}) and True in timevar.values():
            self.flag_some_tv = True
        elif timevar is True:
            self.flag_some_tv = True
        else:
            self.flag_some_tv = False

        #default
        self.flag_missing = False
        if np.isnan(ymat).any():
            self.flag_missing = True
            self.flag_some_tv = True

        unifilter_restricted = False
        # -----------------------------------------------------

        #DO NOT USE THIS OPTION. THIS IS FOR TESTING ONLY
        #NOT ALL CODE IS WORKING

        if 'simulation_smoother' in kwargs.keys():
            simulation_smoother = kwargs['simulation_smoother']
            if simulation_smoother not in ['dejong_shephard',
                                          'FSCK',
                                          'dkbenchmark',
                                          'noname',
                                          'durbin_koopman_ds']:
                self.simulation_smoother = 'durbin_koopman'
            else:
                self.simulation_smoother = kwargs['simulation_smoother']

        else:
            self.simulation_smoother = 'durbin_koopman'


        self.ytilde = np.zeros((nseries, nobs), order='F')
        # -----------------------------------------------------
        if self.simulation_smoother == 'noname':
            typefilter = 'stdfilter'
            typesmoother = 'state'

            # Define appropriate function to be used
            if self.flag_some_tv is True:
                self._sim_smoother = self.__noname_tv
            else:
                self._sim_smoother = self.__noname_ntv
        # ----------------------------------------------------------
        elif self.simulation_smoother == 'durbin_koopman':
            self._sim_smoother = self.__sim_smoother_durbin_koopman
            typefilter = 'stdfilter'
            typesmoother = 'state'

        elif self.simulation_smoother == 'dejong_shephard':
            typefilter = 'stdfilter'
            typesmoother = 'disturbance'
            self.eta = np.zeros((rstate, nobs), order='F')
            self.nl = np.zeros((nstate, nstate), order='F')
            self.nj = np.zeros((nstate, rstate), order='F')
            self.uvec = np.zeros(rstate)
            self.nmat = np.zeros((nstate, nstate), order='F')
            self.wmat = np.zeros((rstate, nstate), order='F')
            self.ct = np.zeros((rstate, rstate), order='F')
            self.vmat = np.zeros((rstate, nstate), order='F')
            self._sim_smoother = self.__sim_smoother_dejong_shephard

            if self.flag_some_tv is True:
                self._dejong_shephard = self._dejong_shephard_tv
            else:
                self._dejong_shephard = self._dejong_shephard_ntv

        elif self.simulation_smoother == 'FSCK':
            #carter and kohn, fruwirth-scnatter simulation smoother

            typefilter = 'c_filter'
            typesmoother = 'cstate'
            self.abar = np.zeros(nstate)
            self.pbar = np.zeros((nstate, nstate), order='F')
            self.rsvec = np.zeros(nstate)
            self.work = np.zeros((nstate, nstate), order='F')

            if self.flag_some_tv is True:
                self._sim_smoother = self.__fsck_tv
            else:
                self._sim_smoother = self.__fsck_ntv

        elif self.simulation_smoother == 'durbin_koopman_ds':
            typesmoother = 'disturbance'
            typefilter = 'stdfilter'
            self._sim_smoother = self.__dk_disturbance_smoother
            kwargs['sim_disturbance'] = True

        else:
                #filter used only for benchmarking. Based on algorithms in Durbin and koopman 2001
                self.benchmark_filter = True
                typefilter = 'dkbenchmark'
                typesmoother = 'state'
                timevar = True
                self.ytilde = np.zeros((nseries, nobs), order='F')
                self._sim_smoother = self.__sim_smoother_durbin_koopman

        self.state_Gresidual = np.zeros((nstate, nobs - 1), order='F')
        if self.flag_some_tv is True:
            self.Gwork = np.zeros(10 * nstate)
            self.Gsvec = np.zeros(rstate)
            self.info = np.array(0.)
        self.state_residual = np.zeros((rstate, nobs - 1), order='F')
        self.meas_residual = np.zeros((nseries, nobs), order='F')
        kwargs['filter'] = typefilter
        kwargs['smoother'] = typesmoother
        kwargs['unifilter_restricted'] = unifilter_restricted
        kwargs['missing'] = self.flag_missing

        # -------------------------------------------------------
        self.filter = FilterBase(nobs, nseries, nstate, rstate, timevar, **kwargs)
        # -------------------------------------------------------
        if self.flag_some_tv is True:
            self._calculate_meas_error = self.__calculate_meas_error_tv
            self._calculate_state_error = self.__calculate_state_error_tv
            self._calculate_state_gerror = self.__calculate_state_gerror_tv
            self._gen_state = self.__gen_state_tv
            self.__state_prob = self.__state_prob_tv
            self.__meas_prob = self.__meas_prob_tv
            self.__calculate_zt_state = self.__calculate_zt_state_tv

        else:
            self._calculate_meas_error = self.__calculate_meas_error_ntv
            self._calculate_state_error = self.__calculate_state_error_ntv
            self._calculate_state_gerror = self.__calculate_state_gerror_ntv
            self._gen_state = self.__gen_state_ntv
            self.__state_prob = self.__state_prob_ntv
            self.__meas_prob = self.__meas_prob_ntv
            self.__calculate_zt_state = self.__calculate_zt_state_ntv
         # -------------------------------------------------------
        system = self.get_system()
        self.flag_some_tv = system.flag_some_tv       # Initialise member variable
        # -------------------------------------------------------
        # Do this code after System class created in Filter object
        if self.simulation_smoother == 'noname':
            properties = system.get_properties()
            self.gt_type = self.__get_index(properties['gt'])
            self.tt_type = self.__get_index(properties['tt'])
            self.qt_type = self.__get_index(properties['qt'])
            self.zt_type = self.__get_index(properties['zt'])
            self.ht_type = self.__get_index(properties['ht'])
            self.rt_type = self.__get_index(properties['rt'])

        #allocate work space for calculation of time varying probability
        if self.flag_some_tv is True:
            self.cgqg = np.zeros((nstate, nstate), order='F')
            self.crhr = np.zeros((nseries, nseries), order = 'F')
            self.work = np.zeros(4 * max(nstate, nseries))
            self.wvec = np.zeros(max(nstate, nseries))
            if system.timevar['gt'] is True or system.timevar['qt'] is True:
                self.lnprst_flag = 0
            else:
                self.lnprst_flag = 1

#   --------------------------------------------------------------------

    def __get_index(self, matrix):
        if matrix == 'eye':
            return 1
        elif matrix == 'diag':
            return 2
        elif matrix == 'inv':
            return 3
        elif matrix == 'chol':
            return 4
        else:
            return 0

#   --------------------------------------------------------------------

    def sim_smoother(self):
        "Funtion runs specified simulation smoother and returns the simulated state."""

        return self._sim_smoother()

#   --------------------------------------------------------------------

    def log_likelihood(self):

        """Function evaluates and returns the log-likelihood"""
        self.filter.update_ymat(self.ymat.copy())
        return self.filter.log_likelihood()

#   --------------------------------------------------------------------

    def update_ymat(self, ymat):
        """Funtion updates the (nseries, nobs) np.array that stores the data"""

        if ymat.ndim == 1:
            self.ymat = np.asfortranarray(ymat.reshape(1, ymat.shape[0]))
        else:
            self.ymat = np.asfortranarray(ymat)
        self.filter.update_ymat(self.ymat.copy())

#   --------------------------------------------------------------------

    def get_ymat(self):
        """Function returns the (nseries, nobs) matrix that stores the
        observations.
        """
        return self.ymat

#   --------------------------------------------------------------------

    def __sim_smoother_durbin_koopman(self):
        """Helper class for the Durbin and Koopman simulation smoother"""

        self.filter.simssm()
        self.stateplus = self.filter.state
        self.ytilde = self.ymat - self.filter.ymat
        self.filter.update_ymat(self.ytilde)
        system = self.get_system()
        a1 = system.a1()
        system.update_a1(np.zeros(system.nstate))

        if system.nreg > 0:
            beta = system.beta()
            if system.sreg == 0:
                tbeta = np.zeros(system.nreg)
            else:
                tbeta = beta.copy()
                tbeta[-system.nreg:] = np.zeros(system.nreg)
            system.update_beta(tbeta)

        self.filter.smoother()
        if system.nreg > 0:
            system.update_beta(beta)
        system.update_a1(a1)

        self.stateplus = self.filter.ahat + self.stateplus
        return self.stateplus

#   --------------------------------------------------------------------

    def __gen_state(self):
        """Helper class for generating the state from the residuals"""

        self._gen_state()

#   --------------------------------------------------------------------

    def __gen_state_tv(self):
        """Helper class for generating the state from the residuals, for the
        case when at least one of the system matrices is timevarying"""

        system = self.filter.get_system()
        stdfilter.genstate(self.eta, system._tt(), system._gt(), self.stateplus)

#   --------------------------------------------------------------------

    def __gen_state_ntv(self):
        """Helper class for generating the state from the residuals, when none of the
        system matrices are time varying."""

        system = self.filter.get_system()
        stdfilter.ntgenstate(self.eta, system._tt(), system._gt(), self.stateplus)

#   --------------------------------------------------------------------

    #DO NOT USE; STILL IN TESTING
    def __noname_tv(self):  # time varying version of noname smoother
        """Helper class; testing only"""

        n1 = self.stateplus.shape[0]
        n2 = self.stateplus.shape[1]
        rv = np.random.randn(n1 * n2)
        self.stateplus = np.asfortranarray(rv)

        ifo = np.array(0)
        sys = self.filter.get_system()
        two_m = 2 * self.filter.nstate
        mn = self.filter.nstate * self.filter.nobs

        # Optimisations: Use cholesky factorisation that is already computed
        #qt = sys.cqt  # Special option
        #self.qt_type = 4
        qt = sys._qt()  # Default option

        # Ht diag case => need to convert to 3 dimensions
        if self.ht_type == 2:  # i.e. ht.ndim == 2:
            p = self.filter.nseries
            n = self.filter.nobs
            ht = np.ones((p, 1, n), order='F')
            # Replace this code: ht[:,0,:] = sys._ht()[:,:]
            ht[:, 0, :] = sys._rhr()[:, :]    # Replace ht with rhr

        else:
        # If Ht in {default, identity, chol} use cholesky factor
            if(self.ht_type != 3):
                # Replace this code: ht = sys._cht()
                ht = sys._rcht()  # Replace ht with rcht
                self.ht_type = 4
            else:
                # Replace this code: ht = sys._ht()
                ht = sys._rhr()  # Replace ht with rhr

# NOTE TO USER: SELECT VERSION
# - Use std version: stdfilter.tv_noname_simsm
# - Use parallel version: stdfilter.tv_noname_simsmp

        stdfilter.tv_noname_simsmp(self.stateplus, self.filter.ymat,
            sys._tt(), ht, sys._zt(), qt, sys._gt(), sys._p1(), sys._a1(),
            self.ht_type, self.zt_type, self.qt_type, self.gt_type,
            self.tt_type, ifo, two_m, mn)

        # Convert np.array into matrix format
        self.stateplus = self.stateplus.reshape(n2, n1).T

        np.savetxt('state_diag.dat', self.stateplus)

        return self.stateplus

#   --------------------------------------------------------------------

    def __noname_ntv(self):
        """Helper class; testing only; not fully debugged
        non time varying version of noname smoother"""

        n1 = self.stateplus.shape[0]   # i.e. nstate
        n2 = self.stateplus.shape[1]   # i.e. nobs
        rv = np.random.randn(n1 * n2)
        self.stateplus = np.asfortranarray(rv)

        sys = self.filter.get_system()
        gt_i = np.linalg.pinv(sys._gt())
        ifo = np.array(0)
        two_m = 2 * self.filter.nstate
        mn = self.filter.nstate * self.filter.nobs

        dense = np.zeros((mn, mn), order='F')  # For debugging only
        rhs_pre = np.zeros(mn)  # , order='F')   # For debugging only

        # Optimisations: use cholesky factorisation that is already computed
        #qt = sys.cqt
        #self.qt_type = 4
        qt = sys._qt()

        # Replace this code: ht = sys._ht()
        ht = sys._rhr()   # Replace ht with rhr

        if(self.ht_type != 2 and self.ht_type != 3):    # i.e. not diag or inv
            # Replace this code: ht = sys._cht()
            ht = sys._rcht()  # Replace ht with rcht
            self.ht_type = 4

        # Ht diag case => need to convert vector to (p,1) matrix
        if ht.ndim == 1:
            ht = np.reshape(ht, (self.filter.nseries, 1), order='F')

        # Call function nt_noname_simsm from file filter.f
        stdfilter.nt_noname_simsm(dense, rhs_pre,
            self.stateplus, self.filter.ymat,
            sys._tt(), ht, sys._zt(), qt, gt_i,
            sys._p1(), sys._a1(), self.ht_type, self.zt_type, self.qt_type,
            self.gt_type, self.tt_type, ifo, two_m, mn)

        # Optional scipy code: Banded matrix version
        # 1. solve bmat.mu = rhs_pre;  2. bmat = L.L'
        # 3. solve L'.x = stateplus    4. state = mu  + x
        #L = scipy.linalg.cholesky_banded(dense, overwrite_ab = True, lower = True)
        #mu = scipy.linalg.cho_solve_banded((L,True), rhs_pre, overwrite_b = False)
        #Lt = np.zeros((L.shape[0], L.shape[1]), order='F')
        #stdfilter.transpose_banded_lower(L, Lt)
        #x = scipy.linalg.cho_solve_banded((Lt,False), self.stateplus, overwrite_b = False)
        #self.stateplus = mu + x

        # Optional numpy code: Dense matrix version
        #mu = np.linalg.solve(dense, rhs_pre)
        #L = np.linalg.cholesky(dense)
        #x = np.linalg.solve(L.T, self.stateplus)
        #self.stateplus = mu + x

        self.stateplus = self.stateplus.reshape(n2, n1).T  # Convert np.array into matrix format

        return self.stateplus

#   --------------------------------------------------------------------

    def __fsck_tv(self):
        """Helper class for the Fruwirth Snatter and Carter and
        Kohn simulation smoother"""

        self.filter.filter()

        # Grab last matrix, vector respectively
        self.pbar = self.filter.pstore[:, :, -1].copy()
        self.abar = self.filter.at_t[:, -1].copy()

        # Create a matrix of random values
        rv = np.random.randn(self.stateplus.shape[0], self.stateplus.shape[1])
        self.stateplus = np.asfortranarray(rv)

        last_t = self.filter.at_t.shape[1]  # No steady state situation

        # Call the simulations smoother
        stdfilter.fscksimsm(self.stateplus, self.filter.astore, self.filter.pt_t,
                   self.filter.at_t, self.filter.work, self.filter.pstore,
                   self.abar, self.pbar, self.rsvec, self.work,
                   self.filter.info, last_t)

        #assert self.filter.info == 0

        return self.stateplus

#   --------------------------------------------------------------------

    def __fsck_ntv(self):
        """Helper class for the Fruwirth Snatter and Carter and Kohn simulation smoother"""

        self.filter.filter()

        # Create a matrix of random values
        rv = np.random.randn(self.stateplus.shape[0], self.stateplus.shape[1])
        self.stateplus = np.asfortranarray(rv)

        # Make a copy.
        self.pbar = self.filter.pstore[:, :, -1].copy()
        self.abar = self.filter.at_t[:, -1].copy()

        # Call the simulations smoother
        stdfilter.fscksimsm(self.stateplus, self.filter.astore, self.filter.pt_t,
                    self.filter.at_t, self.filter.work, self.filter.pstore,
                    self.abar, self.pbar, self.rsvec, self.work,
                    self.filter.info, self.filter.last_t)

        #assert self.filter.info == 0
        return self.stateplus

#   --------------------------------------------------------------------

    def _dejong_shephard_tv(self):
        """Helper class for the de Jong and Shephard simulation smoother, when
        at least one of the system matrices is time varying."""
        #Ensure that columns of y don't include partial missing data
        try:
            assert self.flag_missing != 1
        except:
            error = """If missing data is present in the data either the
            whole column of y must be missing or R(t) and H(t) must both
            be diagonal"""
            raise NotImplementedError(error)

        system = self.filter.get_system()

        stdfilter.dssimsm(self.eta, self.filter.sstore, self.filter.nustore,
            system._zt(), self.wmat, self.uvec, self.filter.lstore,
            self.filter.rvec, self.nmat, self.vmat,
            self.nl, self.filter.jt, self.ct, self.nj, self.filter.ltr,
            system._qt(), self.filter.info, self.filter.partial_missing)

#   --------------------------------------------------------------------

    def _dejong_shephard_ntv(self):
        """Helper class for the de Jong and Shephard simulation smoother, when
        none of the system matrices is time varying."""

        system = self.filter.get_system()

        stdfilter.ntdssimsm(self.eta, self.filter.sstore, self.filter.nustore,
        system._zt(), self.wmat, self.uvec, self.filter.lstore, self.filter.rvec, self.nmat,
        self.vmat, self.nl, self.filter.jt, self.ct, self.nj, self.filter.ltr,
        system._qt(), self.filter.last_t, self.filter.info)

#   --------------------------------------------------------------------

    def __dk_disturbance_smoother(self):
        """Helper class for the Durbin and Koopman disturbance simulation smoother"""

        # Run the filter
        self.filter.smoother()

        # Copy ehat
        ehat = self.filter.ehat.copy()

        # Run the smoother
        self.filter.simssm()

        eplus = self.filter.rand_state

        # Run the filter
        self.filter.smoother()

        # Assign new ehat as ehatplus
        ehatplus = self.filter.ehat

        self.eta = ehat - ehatplus + eplus

        system = self.get_system()

        self.stateplus[:, 0] = np.asfortranarray(system._a1() + np.dot(system._p1(),
                                                                      self.filter.rvec))
        self._gen_state()

        return self.stateplus

#   --------------------------------------------------------------------

    def __sim_smoother_dejong_shephard(self):
        """Helper class for the de Jong and Shepard simulation smoother"""

        self.filter.filter()
        self.filter.update_jt()
        system = self.filter.get_system()
        self.eta = np.asfortranarray(np.random.randn(system._qt().shape[0],
                                                     self.stateplus.shape[1]))

        self._dejong_shephard()
        self.stateplus[:, 0] = np.asfortranarray(system._a1() + np.dot(system._p1(),
                                                                       self.filter.rvec))

        self._gen_state()
        return self.stateplus

#   --------------------------------------------------------------------

    def get_system(self):
        """Function returns the class System, which stores the system matrices for
        the SSM.
        """

        return self.filter.sys

#   --------------------------------------------------------------------

    def get_state(self):
        """Function returns the simulated (nstate, nobs) matrix that stores
        the state.
        """

        return self.stateplus

#   --------------------------------------------------------------------

    def get_state_residual(self, **kwargs):
        """returns the (rstate, nobs) matrix of residuals
                                       for the state.

           optional argument(**kwargs):
               state_index - An index specifying what elements
               of the state vector that you want the residuals
               for. For example if you want the first three
               elements of the state, then

               state_index = np.array([0,1,2]) is passed to the
               function.
        """

        self._calculate_state_error(**kwargs)
        if 'state_index' not in kwargs:
            return self.state_residual
        else:
            return self.state_residual[kwargs['state_index'], :]

#   --------------------------------------------------------------------
    def compute_gresidual(self, ** kwargs):
        """returns state_Gresidual as G(t)*eta(t)"""
        self._calculate_state_gerror(**kwargs)
        return self.state_Gresidual

#   --------------------------------------------------------------------

    def __calculate_state_gerror_tv(self, **kwargs):
        """computes state_Gresidual as G(t)*eta(t)
        optional argument (**kwargs):
            state_index - computes only state_Gresidual[state_index,:].
                          That is only the rows in state_Gresidual
                          corresponding to state_index are computed
        """

        if 'state_index' not in kwargs:
            uni.state_res(self.stateplus, self.filter.sys._tt(), self.state_Gresidual)
        else:
            index = kwargs['state_index']
            uni.state_res(self.stateplus[index, :], self.filter.sys._tt()[index][:, index],
                         self. state_Gresidual[index, :])

#   --------------------------------------------------------------------

    def __calculate_state_error_tv(self, **kwargs):
        """Helper class for calculating the state residuals, when at least
        one of the system matrices is time varying."""

        self.__calculate_state_gerror_tv(**kwargs)

        if 'state_index' not in kwargs:
            system = self.get_system()
            properties = system.get_properties()
            if properties['gt'] == 'eye':
                self.state_residual = self.state_Gresidual
            else:
                if system.timevar['gt'] is True:
                    gt = system._gt().copy()
                    uni.gres_res(self.state_Gresidual, gt, self.Gwork, self.Gsvec, self.info)
                    self.state_residual = self.state_Gresidual[0:system._qt().shape[0], :]
                else:
                    pinvg = np.linalg.pinv(system.gt())
                    self.state_residual = np.dot(pinvg, self.state_Gresidual)

        else:
            index = kwargs['state_index']
            system = self.get_system()
            properties = system.get_properties()
            if properties['gt'] == 'eye':
                self.state_residual[index, :] = self.state_Gresidual
            else:
                gt = system._gt().copy()
                if system.timevar['gt'] is True:
                    uni.gres_res(self.state_Gresidual, gt,
                             self.Gwork, self.Gsvec, self.info)
                    self.state_residual[index, :] = self.state_Gresidual[index]
                else:
                    pinvg = np.linalg.pinv(system.gt())[index][:, index]
                    self.state_residual = np.dot(pinvg, self.state_Gresidual[index])
#   --------------------------------------------------------------------

    def __calculate_state_gerror_ntv(self, **kwargs):
        """computes state_Gresidual as G(t)*eta(t)
        optional argument (**kwargs):
            state_index - computes only state_Gresidual[state_index,:].
                          That is only the rows in state_Gresidual
                          corresponding to state_index are computed
        """

        if 'state_index' not in kwargs:
            uni.ntstate_res(self.stateplus, self.filter.sys.tt(), self.state_Gresidual)
        else:
            index = kwargs['state_index']

            #print "CHECK Gresidual[index,:] or [:,index]"
            #pdb.set_trace()
            uni.ntstate_res(self.stateplus[index], self.filter.sys._tt()[index][:, index],
                                self.state_Gresidual[index])

#   --------------------------------------------------------------------

    def __calculate_state_error_ntv(self, **kwargs):
        """Helper class for calculating the state residuals when none of the
        system matrices are time varying."""

        self.__calculate_state_gerror_ntv(**kwargs)
        if 'state_index' not in kwargs:
            uni.ntstate_res(self.stateplus, self.filter.sys.tt(), self.state_Gresidual)
            system = self.get_system()
            properties = system.get_properties()
            if properties['gt'] == 'eye':
                self.state_residual = self.state_Gresidual
            else:
                self.state_residual = np.dot(np.linalg.pinv(system.gt()), self.state_Gresidual)

        else:
            index = kwargs['state_index']
            system = self.get_system()
            properties = system.get_properties()
            if properties['gt'] == 'eye':
                self.state_residual[index] = self.state_Gresidual[index]
            else:
                self.state_residual[index] = np.dot(np.linalg.pinv(system._gt())[index][:, index],
                                                   self.state_Gresidual[index])

#   --------------------------------------------------------------------

    def get_meas_residual(self, **kwargs):
        """Function returns the residuals from the measurement equation.
           Optional argument:
               rteps: Set to True if the user wants to return R(t)*residual
                      rather that simply the residual

        """

        self._calculate_meas_error(**kwargs)
        return self.meas_residual

#   --------------------------------------------------------------------

    def get_ztilde(self, zt, ztilde):

        if self.self.flag_some_tv is True:
            uni.calc_ztilde(zt, self.stateplus, ztilde)

        else:
            uni.ntcalc_ztilde(zt, self.stateplus, ztilde)

#   --------------------------------------------------------------------

    def get_zt_times_state(self, **kwargs):
        """function returns a za(p,m) np.array, where za(:,t) = zt * state(:,t) for
        t = 1,2,... ,n.
        """

        if 'zt' in kwargs:
            zt = np.asfortranarray(kwargs['zt'])
        else:
            zt = self.filter.sys._zt()

        if self.self.flag_some_tv is False:
            return np.dot(zt, self.stateplus)
        else:
            uni.zt_alpha(zt, np.asfortranarray(self.stateplus), np.asfortranarray(self.ytilde))
            return self.ytilde

#   --------------------------------------------------------------------

    def calculate_ystar(self, number, meas_residual, ystar, xstar, ztilde):
        uni.calc_ystar(meas_residual, ystar, ztilde, xstar, number + 1)

#   --------------------------------------------------------------------
    def calculate_zt_state(self):
        """returns zt * state"""

        return self.__calculate_zt_state()

#   --------------------------------------------------------------------

    def __calculate_zt_state_ntv(self):
        """
        returns zt * state for non time varying system matrices
        """
        self.ytilde = np.asfortranarray(self.ytilde)
        stdfilter.calc_zt_s_ntv(self.stateplus, self.filter.sys._zt(),
                                self.ytilde)

        return self.ytilde

#   --------------------------------------------------------------------
    def __calculate_zt_state_tv(self):
        """
        returns zt * state when some of the system matrices are time
        varying
        """
        self.ytilde = np.asfortranarray(self.ytilde)
        stdfilter.calc_zt_s_tv(self.stateplus, self.filter.sys._zt(),
                                self.ytilde)

        return self.ytilde

#   --------------------------------------------------------------------

    def __calculate_meas_error_tv(self, **kwargs):
        """Helper function for calculating the measurement error when at least
        one of the system matrices is time varying."""

        if self.filter.sys.properties['rt'] == 'eye':
            rt_eye = True
        else:
            rt_eye = False

        rt = self.filter.sys._rt()

        if 'rteps' in kwargs and kwargs['rteps'] is True:
            rteps = 1  # compute R(t)*residual instead of residual
        else:
            rteps = 0
            if rt_eye == False:
                rt = self.filter.sys._rt().copy()

        uni.meas_res(self.ymat, self.filter.sys._zt(), self.stateplus,
            self.meas_residual, rt, rt_eye, rteps)

#   --------------------------------------------------------------------

    def __calculate_meas_error_ntv(self, **kwargs):
        """Helper function for calculating the measurement error when none of
        the system matrices are time varying."""

        if self.filter.sys.properties['rt'] == 'eye':
            rt_eye = True
        else:
            rt_eye = False

        rt = self.filter.sys._rt()

        if 'rteps' in kwargs and kwargs['rteps'] is True:
            rteps = 1  # compute R(t)*residual instead of residual
        else:
            rteps = 0
            if rt_eye == False:
                rt = self.filter.sys._rt().copy()



        uni.ntmeas_res(self.ymat, self.filter.sys._zt(), self.stateplus,
                       self.meas_residual, rt,
                       rt_eye, rteps)


#   --------------------------------------------------------------------

    def log_probability_state(self, **kwargs):
        """Function returns the log probabiltiy of the simulated state.
          optional arguments:
              state_index - An index specifying a subset
              of the state that you what to evaluate the
              probability of.

              diffuse - Should equal True if diffuse initial conditions were
              used

        """

        # log probability of initial state defined up to a constant of proportionality
        system = self.get_system()
        cond_diffuse = ('diffuse' in kwargs and kwargs['diffuse'] is True)

        if 'state_index' not in kwargs:

            if cond_diffuse:
                lnpr = 0.0
            else:

                # Solve: cholp1 * rvec = state(0) - a1
                rvec = np.linalg.solve(system._cholp1(),
                                   self.stateplus[:, 0] - system._a1())

                # lnpr = -0.5 * (rvec . rvec) - 0.5 * np.log(determinant)
                lnpr = -0.5 * np.dot(rvec, rvec) -\
                    np.sum(np.log(np.diag(system._cholp1())))


            lnpr = lnpr - 0.5 * self.filter.nobs * self.filter.rstate * \
                    np.log(2.0 * np.pi)

            self._calculate_state_error()
            lnprstate = self.__state_prob()
            return lnpr + lnprstate
        else:
            index = kwargs['state_index']
            if cond_diffuse:
                lnpr = 0.0
            else:

                # Solve: mess * rvec = (state(index,0) - a1(index))
                # where mess = cholp1[i][:,i] & i = index
                rvec = np.linalg.solve(system._cholp1()[np.array(index)][:,
                     np.array(index)],
                     self.stateplus[index, 0] - system._a1()[index])

                # lnpr = -0.5 * (rvec . rvec)
                lnpr = -0.5 * np.dot(rvec, rvec)

            lnpr = lnpr - 0.5 * self.filter.nobs * index.shape[0] * \
                    np.log(2.0 * np.pi)
            self._calculate_state_error(**kwargs)
            lnprstate = self.__state_prob(**kwargs)
            return lnpr + lnprstate

#   --------------------------------------------------------------------

    def __state_prob_tv(self, **kwargs):
        """Helper function for calculating the state probability, when at least
        one of the system matrices is time varying"""

        if 'state_index' not in kwargs:
            system = self.get_system()
            lnprstate = np.array(0.0)
            info = np.array(0)

            stdfilter.lnprst(lnprstate, self.state_residual, system._cqt(),
                        system._gqg(), self.cgqg, self.wvec, self.work, info,
                            self.lnprst_flag)

            assert info == 0
            return lnprstate
        else:
            index = kwargs['state_index']
            system = self.get_system()
            lnprstate = np.array(0.)
            stdfilter.lnprst(lnprstate, self.state_residual[index, :],
                             system._cqt()[index][:, index],
                             system._gcqt()[index][:, index])
            return lnprstate

#   --------------------------------------------------------------------

    def __state_prob_ntv(self, **kwargs):
        """Helper function for calculating the state probability, when
        none of the system matrices is time varying"""

        if 'state_index' not in kwargs:
            system = self.get_system()
            lnprstate = np.array(0.)
            stdfilter.ntlnprst(lnprstate, self.state_residual, system._cqt())
            #adjust for generalised determinant calculation
            E, V = np.linalg.eig(system.gqg())
            lnprstate = lnprstate - 0.5 * (self.filter.nobs - 1) * np.log(E[E > 1E-6]).sum()
            return lnprstate
        else:
            index = kwargs['state_index']
            system = self.get_system()
            lnprstate = np.array(0.)
            stdfilter.ntlnprst(lnprstate, self.state_residual[index, :], system._cqt()[index][:, index])
            #adjust for generalised determinant calculation
            E, V = np.linalg.eig(system.gqg()[index][:, index])
            lnprstate = lnprstate - 0.5 * (self.filter.nobs - 1) * np.log(E[E > 1E-6]).sum()
            return lnprstate

#   --------------------------------------------------------------------

    def log_probability_meas(self):
        """Function returns the log probability of the measurment
        equation condional on the state and the system matrices."""

        self._calculate_meas_error()
        return self.__meas_prob()

#   --------------------------------------------------------------------

    def __meas_prob_tv(self):
        """Helper function for calculating the measurement probability when at least
        one of the system matrices are time varying."""

        lnprmeas = np.array(0.)
        system = self.get_system()
        info = np.array(0)
        cht = system._cht()  # Replace cht with rcht
        if system.timevar['rt'] is True or system.timevar['ht'] is True:
            self.lnprst_flag = 0
        else:
            self.lnprst_flag = 1

        stdfilter.lnprst(lnprmeas, self.meas_residual, cht, system._rhr(),
                        self.crhr, self.wvec, self.work, info, self.lnprst_flag )

        lnprmeas = lnprmeas -0.5 * system.nobs * system.nseries * np.log(2.0 * np.pi)
        return lnprmeas

#   --------------------------------------------------------------------

    def __meas_prob_ntv(self):
        """Helper function for calculating the measurement probability when
        none of the system matrices are time varying."""

        lnprmeas = np.array(0.)
        system = self.get_system()
        nobs = system.nobs
        nseries = system.nseries

        cht = system._cht()  # Replace cht with rcht
        stdfilter.ntlnprst(lnprmeas, self.meas_residual, cht)
        lnprmeas = lnprmeas -0.5 * nobs * nseries * np.log(2.0 * np.pi)
        lnprmeas = lnprmeas - nobs * np.log(np.diag(np.linalg.cholesky(system.rhr()))).sum()
        return lnprmeas

#-----------------------------------------------------------------------
